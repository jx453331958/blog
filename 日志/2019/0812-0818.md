**[React v16.9.0 and the Roadmap Update](https://reactjs.org/blog/2019/08/08/react-v16.9.0.html)**

**Renaming Unsafe Lifecycle Methods:**
- `componentWillMount` → `UNSAFE_componentWillMount`
- `componentWillReceiveProps` → `UNSAFE_componentWillReceiveProps`
- `componentWillUpdate` → `UNSAFE_componentWillUpdate`

**Deprecating javascript: URLs**
```javascript
const userProfile = {
  website: "javascript: alert('you got hacked')",
};
// This will now warn:
<a href={userProfile.website}>Profile</a>
```
In React 16.9, this pattern continues to work, but it will log a warning.
In a future major release, React will throw an error if it encounters a javascript: URL.

**Deprecating “Factory” Components**
```javascript
function FactoryComponent() {
  return { render() { return <div />; } }
}
```
This pattern is confusing because it looks too much like a function component — but it isn’t one. (A function component would just return the `<div />` in the above example.)

This pattern was almost never used in the wild, and supporting it causes React to be slightly larger and slower than necessary. So we are deprecating this pattern in 16.9 and logging a warning if it’s encountered.

**Features**

1. Async act() for Testing: React 16.8 introduced a new testing utility called act() to help you write tests that better match the browser behavior. However, in 16.8 act() only supported synchronous functions. In React 16.9, act() also accepts asynchronous functions, and you can await its call.
2. Performance Measurements with <React.Profiler>: In React 16.9, we are also adding a programmatic way to gather measurements called <React.Profiler>. The <Profiler> measures how often a React application renders and what the “cost” of rendering is. Its purpose is to help identify parts of an application that are slow and may benefit from optimizations such as memoization.

---

**[Async Generator Functions in JavaScript](http://thecodebarbarian.com/async-generator-functions-in-javascript.html)**

**JavaScript has 6 distinct types of functions:**
- Normal functions `function() {}`
- Arrow functions `() => {}`
- Async functions `async function() {}`
- Async arrow functions `async () => {}`
- Generator functions `function*() {}`
- Async generator functions `async function*() {}`

Async generator functions behave similarly to generator functions: the generator function returns an object that has a next() function, and calling next() executes the generator function until the next yield. The difference is that an async iterator's next() function returns a promise.

```javascript
'use strict';

async function* run() {
  await new Promise(resolve => setTimeout(resolve, 100));
  yield 'Hello';
  console.log('World');
}

// `run()` returns an async iterator.
const asyncIterator = run();

// The function doesn't start running until you call `next()`
asyncIterator.next().
  then(obj => console.log(obj.value)). // Prints "Hello"
  then(() => asyncIterator.next());  // Prints "World"
```

The cleanest way to loop through an entire async generator function is using a for/await/of loop.

```javascript
'use strict';

async function* run() {
  await new Promise(resolve => setTimeout(resolve, 100));
  yield 'Hello';
  console.log('World');
}

const asyncIterator = run();

// Prints "Hello\nWorld"
(async () => {
  for await (const val of asyncIterator) {
    console.log(val); // Prints "Hello"
  }
})();
```

---

