**[JavaScript and Node Testing Best Practices](https://github.com/goldbergyoni/javascript-testing-best-practices)**

**Include 3 parts in each test name**
1. What is being tested? For example, the ProductsService.addNewProduct method
2. Under what circumstances and scenario? For example, no price is passed to the method
3. What is the expected result? For example, the new product is not approved

example: 
```javascript
//1. unit under test
describe('Products Service', function() {
  describe('Add new product', function() {
    //2. scenario and 3. expectation
    it('When no price is specified, then the product status is pending approval', ()=> {
      const newProduct = new ProductService().add(...);
      expect(newProduct.status).to.equal('pendingApproval');
    });
  });
});
```

**Structure tests by the AAA pattern**
Structure your tests with 3 well-separated sections Arrange, Act & Assert (AAA). 
1. 1st A - Arrange: All the setup code to bring the system to the scenario the test aims to simulate. This might include instantiating the unit under test constructor, adding DB records, mocking/stubbing on objects and any other preparation code
2. 2nd A - Act: Execute the unit under test. Usually 1 line of code
3. 3rd A - Assert: Ensure that the received value satisfies the expectation. Usually 1 line of code

example:
```javascript
describe('Customer classifier', () => {
    test('When customer spent more than 500$, should be classified as premium', () => {
        //Arrange
        const customerToClassify = {spent:505, joined: new Date(), id:1}
        const DBStub = sinon.stub(dataAccess, "getCustomer")
            .reply({id:1, classification: 'regular'});

        //Act
        const receivedClassification = customerClassifier.classifyCustomer(customerToClassify);

        //Assert
        expect(receivedClassification).toMatch('premium');
    });
});
```

**Describe expectations in a product language: use BDD-style assertions**
Coding your tests in a declarative-style allows the reader to get the grab instantly without spending even a single brain-CPU cycle.

example:
```javascript
it("When asking for an admin, ensure only ordered admins in results" , ()={
    //assuming we've added here two admins
    const allAdmins = getUsers({adminOnly:true});

    expect(allAdmins).to.include.ordered.members(["admin1" , "admin2"])
  .but.not.include.ordered.members(["user1"]);
});
```

**Stick to black-box testing: Test only public methods**
Whenever a public behavior is checked, the private implementation is also implicitly tested and your tests will break only if there is a certain problem.

**Choose the right test doubles: Avoid mocks in favor of stubs and spies**
> 测试双打

example:
```javascript
it("When a valid product is about to be deleted, ensure an email is sent", async () => {
    //Assume we already added here a product
    const spy = sinon.spy(Emailer.prototype, "sendEmail");
    new ProductService().deletePrice(theProductWeJustAdded);
    //hmmm OK: we deal with internals? Yes, but as a side effect of testing the requirements (sending an email)
});
```

**Don’t “foo”, use realistic input dataing**
Often production bugs are revealed under some very specific and surprising input — the more realistic the test input is, the greater the chances are to catch bugs early. Use dedicated libraries like Faker to generate pseudo-real data that resembles the variety and form of production data.

example:
```javascript
it("Better: When adding new valid product, get successful confirmation", async () => {
    const addProductResult = addProduct(faker.commerce.productName(), faker.random.number());
    //Generated random input: {'Sleek Cotton Computer',  85481}
    expect(addProductResult).to.be.true;
    //Test failed, the random input triggered some path we never planned for.
    //We discovered a bug early!
});
```

**Test many input combinations using Property-based testing**

