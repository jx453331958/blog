# HTTP 权威指南

## 第 7 章 缓存

1. 使用缓存有以下优点：

    1. 缓存减少了冗余的数据传输，节省了网络费用。
    2. 缓存缓解了网络瓶颈的问题。不需要更多的宽带就能够更快地加载页面。
    3. 缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。
    4. 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。

2. 冗余的数据传输：有很多客户端访问一个流行的原始服务器页面时，服务器会多次传输同一份文档，每次传送给一个客户端。一些相同的字节会在网络中一遍遍地传输。这些冗余的数据传输会耗尽昂贵的网络带宽，降低传输速度，加重服务器的负载。有了缓存，就可以保留第一条服务器响应的副本，后继请求就可以由缓存的副本来应对了。这样可以减少流入/流出原始服务器的重复流量。

3. 缓存可以缓解网络的瓶颈问题。很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器。如果客户端从一个快速局域网的缓存中得到了一份副本，那么缓存就可以提高性能。

4. 瞬间拥塞：缓存在破坏瞬间拥塞时非常重要。很多人同一时间访问一个 Web 文档时，就会出现瞬间拥塞。由此造成的过多流量峰值可能会使网络和 Web 服务器产生灾难性的崩溃。

5. 距离时延：每台网络路由器都会增加因特网流量的时延，即使客户端和服务器之间没有太多的路由器，光速自身也会造成显著的时延。

6. 命中和未命中：可以用已有的副本为某些到达缓存的请求提供服务，称为缓存命中。没有副本可用而被转发给原始服务器称为缓存未命中。

7. 再验证：原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本。缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的 304Not Modified 进行响应。

8. HTTP 提供的验证工具：If-Modified-Since 首部。将这个首部添加到 GET 请求中去，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。

9. 命中率：由缓存提供服务的请求所占的比例被称为缓存命中率。缓存的管理者希望缓存命中率接近 100%，而实际得到的命中率则与缓存的大小、缓存用户兴趣点的相似性、缓存数据的变化或个性化频率，以及如何配置缓存有关。

10. 字节命中率：由于文档并不全是同一尺寸的，所以文档命中率并不能说明一切。有些大型对象被访问的次数可能较少，但由于尺寸的原因，对整个数据流量的贡献却更大。因此，有些人更愿意使用字节命中率作为度量值。

11. 区分命中和未命中的情况：客户端有一种方法可以判断响应是否来自缓存，就是使用 Date 首部。将响应中 Date 首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存的响应。客户端也可以通过 Age 首部来检测缓存的响应，通过这个首部可以分辨出这条响应的使用期。

12. 缓存的拓扑结构：缓存可以是单个用户专用的，也可以是数千名用户共享的。专用缓存被称为私有缓存。共享的缓存被称为公有缓存。

13. 代理缓存的层次结构：实现层次化的缓存是很有意义的，在这种结构中，在较小缓存中未命中的请求会被导向较大的父缓存，由它来为剩下的那些“提炼过的”流量服务。

14. 网状缓存、内容路由及对等缓存：有些网络结构会构建复杂的网状缓存，而不是简单的缓存层次结构。网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为内容路由器。

    1. 网状缓存中为内容路由设计的缓存要完成下列所有功能：
        1. 根据 URL 在父缓存或原始服务器之间进行动态选择
        2. 根据 URL 动态地选择一个特定的父缓存
        3. 前往父缓存之前，在本地缓存中搜索已缓存的副本
        4. 允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过它们的缓存
    2. 缓存之间这些更为复杂的关系允许不同的组织互为对等实体，将他们的缓存连接起来以实现共赢。提供可选的对等支持的缓存被称为兄弟缓存。HTTP 并不支持兄弟缓存。

15. 缓存的处理步骤：

    1. 接收：缓存从网络请求中读取抵达的请求报文
    2. 解析：缓存对报文进行解析，提取出 URL 和各种首部
    3. 查询：缓存查看是否有本地副本可用，如果没有，就获取一份副本
    4. 新鲜度检测：缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新
    5. 创建响应：缓存会用新的首部和已缓存的主体来构建一条响应报文
    6. 发送：缓存通过网络将响应发回给客户端
    7. 日志：缓存可选地创建一个日志文件条目来描述这个事务

16. HTTP 有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP 将这些简单的机制称为文档过期和服务器再验证。

17. 文档过期：通过特殊的 HTTP Cache-Control 首部和 Expires 首部，HTTP 让原始服务器向每个文档附加了一个“过期时间”。这些首部说明了在多长时间内可以将这些内容视为新鲜的。在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系，除非客户端请求中包含有阻止提供已缓存或未验证资源的首部。

18. Expires 首部使用的是绝对日期，Cache-Control 使用的是相对日期，所以更倾向于使用比较新的 Cache-Control 首部。

19. 服务器再验证：缓存需要询问原始服务器文档是否发生了变化

    1. 如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。
    2. 如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期时间，并对缓存中的首部进行更新就行了。

20. 缓存并不一定要为每条请求验证文档的有效性，只有在文档过期时它才需要与服务器进行再验证。这样不会提供陈旧的内容，还可以节省服务器的流量，并拥有更好的用户响应时间。

21. HTTP 协议要求行为正确的缓存返回下列内容之一：
    1. “足够新鲜”的已缓存副本
    2. 与服务器进行过再验证，确认其仍然新鲜的已缓存副本
    3. 如果需要与之进行再验证的原始服务器出故障了，就返回一条错误报文
    4. 附有警告信息说明内容可能不正确的已缓存副本

22. 用条件方法进行再验证：
