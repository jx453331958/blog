# HTTP 权威指南

## 第 12 章 基本认证机制

1. HTTP 的质询/响应认证框架：HTTP 提供了一个原生的质询/响应框架，简化了对用户的认证过程。应用程序收到一条 HTTP 请求报文时，服务器没有按照请求执行动作，而是以一个“认证质询”进行响应，要求用户提供一些保密信息来说明他是谁，从而对其进行质询。用户再次发起请求时，要附上保密证书（用户名和密码）。如果证书不匹配，服务器可以再次质询客户端，或产生一条错误信息。如果证书匹配，就可以正常完成请求了。

2. 认证协议与首部：HTTP 提供一组可定制的控制首部，为不同的认证协议提供了一个可扩展框架。
   |步骤|首部|描述|方法/状态|
   |:-|:-|:-|:-|
   |请求质询|WWW-Authenticate|第一条请求没有认证信息，服务器用 401 状态拒绝了请求，说明需要用户提供用户名和密码|GET 401 Unauthorized|
   |授权|Authorization|客户端重新发出请求，但这一次会附加一个 Authorization 首部，用来说明认证算法、用户名和密码|GET|
   |成功|Authentication-Info|如果授权证书是正确的，服务器就会将文档返回。有些授权算法会在可选的 Authentication-Info 首部返回一些与授权会话相关的附加信息|200 OK|

3. HTTP 定义了两个官方的认证协议：基本认证和摘要认证

4. 基本认证：在基本认证中，服务器可以拒绝一个事务，质询客户端，请用户提供有效的用户名和密码。服务器会返回 401 状态码，而不是 200 状态码来初始化认证质询，并用 WWW-Authenticate 响应首部指定要访问的安全域。浏览器收到质询时，会打开一个对话框，请求用户输入这个域的用户名和密码。然后将用户名和密码稍加扰码，再用 Authorization 请求首部回送给服务器。

5. HTTP 基本认证将（由冒号分隔的）用户名和密码打包在一起，并用 Base-64 编码方式对其进行编码。Base-64 编码会将一个 8 位字节序列划分为一些 6 位的块。用每个 6 位的块在一个特殊的由 64 个字符组成的字母表中选择一个字符，这个字母表中包含了大部分的字母和数字。Base-64 编码可以接受二进制字符串、文本、国际字符表示的数据，将其暂时转换成一个易移植的字母表以便传输。然后在远端就可以解码出原始字符串，而无需担心传输错误。

6. 基本认证的安全缺陷：
    1. 基本认证会通过网络发送用户名和密码，这些用户名和密码都是以一种很容易解码的形式表示的。实际上，密码是以明文形式传输的，任何人都可以读取并将其捕获。虽然 Base-64 编码通过隐藏用户名和密码，致使友好的用户不太可能在进行网络观测时无意中看到密码，但 Base-64 编码的用户名和密码可以很轻易地通过反向编码过程进行解码，甚至可以用纸和笔在几秒钟内手工进行解码。所以经过 Base-64 编码的密码实际上就是“明文”传送的。如果有动机的第三方用户有可能会去拦截基本认证发送的用户名和密码，就要通过 SSL 加密信道发送所有的 HTTP 事务，或者使用更安全的认证协议，比如摘要认证。
    2. 即使密码是以更难解码的方式加密的，第三方用户仍然可以捕获被服务器修改过的用户名和密码，并将修改过的用户名和密码一次一次地重放给原始服务器，以获取对原始服务器的访问权。没有什么措施可以用来防止这些重放攻击。
    3. 即使将基本认证用于一些不太重要的应用程序，比如公司内部网络的访问控制或个性化内容的访问，一些不良习惯也会让它变得很危险。很多用户由于受不了大量密码保护的服务，会在这些服务之间使用相同的用户名和密码。
    4. 基本认证没有提供任何针对代理和作为中间人的中间节点的防护措施，它们没有修改认证首部，但却修改了报文的其余部分，这样就严重地改变了事务的本质。
    5. 假冒服务器很容易骗过基本认证。如果在用户实际连接到一台恶意服务器或网关的时候，能够让用户相信他连接的是一个受基本认证保护的合法主机，攻击者就可以请求用户输入密码，将其存储起来以备未来使用，然后捏造一条错误信息回送给用户。
