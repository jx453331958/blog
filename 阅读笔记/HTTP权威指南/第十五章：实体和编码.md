# HTTP 权威指南

## 第 15 章 实体和编码

1. HTTP/1.1 版定义了 10 个基本实体首部字段：

   1. Content-Type：实体中承载对象的类型
   2. Content-Length：所传送实体主体的长度或大小
   3. Content-Language：与所传送对象最相配的人类语言
   4. Content-Encoding：对象数据所做的任意变换
   5. Content-Location：一个备用位置，请求时可通过它获得对象
   6. Content-Range：如果这是部分实体，这个首部说明它是整体的哪个部分
   7. Content-MD5：实体主体内容的校验和
   8. Last-Modified：所传输内容在服务器上创建或最后修改的日期时间
   9. Expires：实体数据将要失效的日期时间
   10. Allow：该资源所允许的各种请求方法
   11. ETag：这份文档特定实例的唯一验证码。没有正式定义为实体首部。
   12. Cache-Control：指出该如何缓存文档。没有正式定义为实体首部。

2. Content-Length 首部指示出报文中实体主体的字节大小。这个大小是包含了所有内容编码的，比如对文本文件进行了 gzip 压缩的话，Content-Length 首部就是压缩后的大小，而不是原始大小。除非使用了分块编码，否则 Content-Length 首部就是带有实体主体的报文必须使用的。使用 Content-Length 首部是为了能够检测出服务器崩溃而导致的报文截尾，并对共享持久连接的多个报文进行正确分段。

3. 检测截尾：HTTP 的早期版本采用关闭连接的颁发来规定报文的结束。但是没有 Content-Length 的话，客户端无法区分到底是报文结束时正常的连接关闭，还是报文传输中由于服务器崩溃而导致的连接关闭。客户端需要通过 Content-Length 来检测报文截尾。

4. Content-Length 与持久连接：Content-Length 首部对于持久连接是必不可少的。如果响应通过持久连接传送，就可能有另一条 HTTP 响应紧随其后。客户端通过 Content-Length 首部就可以知道报文在何处结束，下一条报文从何处开始。因为连接是持久的，客户端无法依赖连接关闭来判断报文的结束。

5. 内容编码：HTTP 允许对实体主体的内容进行编码，比如可以使之更安全或进行压缩以节省空间。如果主体进行了内容编码，Content-Length 首部说明的就是编码后的主体的字节长度，而不是未编码的原始主体的长度。

6. 确定实体主体长度的规则：

   1. 如果特定的 HTTP 报文类型中不允许带有主体，就忽略 Content-Length 首部，它是对主体进行计算的。这种情况下，Content-Length 首部是提示性的，并不说明实际的主体长度。
   2. 如果报文含有描述传输编码的 Transfer-Encoding 首部，那实体就应由一个称为“零字节块”的特殊模式结束，除非报文已经因为连接关闭而结束。
   3. 如果报文中含有 Content-Length 首部，而且没有非恒等的 Transfer-Encoding 首部字段，那么 Content-Length 的值就是主体的长度。如果收到的报文中既有 Content-Length 首部字段又有非恒等的 Transfer-Encoding 首部字段，那就必须忽略 Content-Length，因为传输编码会改变实体主体的表示和传输方式。
   4. 如果报文使用了 multipart/byteranges(多部分/字节范围)媒体类型，并且没有用 Content-Length 首部指出实体主体的长度，那么多部分报文中的每个部分都要说明它自己的大小。这种多部分类型是唯一的一种自定界的实体主体类型，因此除非发送方知道接收方可以解析它，否则就不能发送这种媒体类型。
   5. 如果上面的规则都不匹配，实体就在连接关闭的时候结束。

7. 实体摘要：为检测实体主体数据是否被修改过，发送方可以在生成初始的主体时，生成一个数据的校验和，这样接收方就可以通过检查这个校验和来捕获所有意外的实体修改了。

8. 服务器使用 Content-MD5 首部发送对实体主体运行 MD5 算法的结果。只有产生响应的原始服务器可以计算并发送 Content-MD5 首部。中间代理和缓存不应当修改或添加这个首部，否则就会与验证端到端完整性这个最终目的相冲突。

9. 内容编码：HTTP 应用程序有时在发送之前需要对内容进行编码。例如压缩或加密。

10. 内容编码过程：

    1. 服务器生成原始响应报文，其中有原始的 Content-Type 和 Content-Length 首部。
    2. 内容编码服务器创建编码后的报文。编码后的报文有同样的 Content-Type 但 Content-Length 可能不同。内容编码服务器在编码后的报文中增加 Content-Encoding 首部，这样接收的应用程序就可以进行解码了。
    3. 接收程序得到编码后的报文，进行解码，获得原始报文。

11. Accept-Encoding 首部：为了避免服务器使用客户端不支持的编码方式，客户端就把自己支持的内容编码方式列表放在请求的 Accept-Encoding 首部里发出去。如果 HTTP 请求中没有包含 Accept-Encoding 首部，服务器就可以假设客户端能够接受任何编码方式。

12. 传输编码和分块编码：传输编码是作用在实体主体上的可逆变换，但使用它们是由于架构方面的原因，同内容的格式无关。

13. 在 HTTP 中，只有少数一些情况下，所传输的报文主体可能会引发问题：

    1. 未知的尺寸：如果不先生成内容，某些网关应用程序和内容编码器就无法确定报文主体的最终大小。通常，这些服务器希望在知道大小之前就开始传输数据。因为 HTTP 协议要求 Content-Length 首部必须在数据之前，有些服务器就使用传输编码来发送数据，并用特别的结束脚注表明数据结束。
    2. 安全性：可以使用传输编码来把报文内容扰乱，然后在共享的传输网络上发送。但是由于像 SSL 这样的传输层安全体系的流行，很少需要靠传输编码来实现安全性。

14. HTTP 协议中只定义了下面两个首部来描述和控制传输编码：

    1. Transfer-Encoding：告知接收方为了可靠地传输报文，已对其进行了何种编码。
    2. TE：用在请求首部中，告知服务器可以使用哪些传输编码扩展。

15. 分块编码：分块编码是把报文分割为若干个大小已知的块，块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。要注意的是，分块编码是一种传输编码，因此是报文的属性，而不是主体的属性。

16. 当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。分块编码为这种困难提供了解决方案，只要允许服务器把主体逐块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完成之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号。

17. 传输编码的规则：

    1. 传输编码集合中必须包括“分块”。唯一的例外是使用关闭连接来结束报文。
    2. 当使用分块传输编码时，它必须是最后一个作用到报文主体之上的。
    3. 分块传输编码不能多次作用到一个报文主体上。

18. 范围请求：HTTP 允许客户端实际上只请求文档的一部分。Range 首部。

19. 差异编码：差异编码是 HTTP 协议的一个扩展，它通过交换对象改变的部分而不是完整的对象来优化传输性能。
