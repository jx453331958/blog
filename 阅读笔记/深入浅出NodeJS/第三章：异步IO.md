# 深入浅出 NodeJS

## 第 3 章 异步 I/O

1. 业务场景中有一组互不相关的任务需要完成，现行的主流方法有以下两种：

   - 单线程串行依次执行
   - 多线程并行完成

2. 如果创建多线程的开销小于并行执行，那么多线程的方式是首选的。多线程的代价在于创建线程和执行期线程上下文切换的开销较大。另外在复杂的业务中，多线程编程经常面临锁、状态同步等问题，这是多线程被诟病的主要原因。但是多线程在多核 CPU 上能够有效提升 CPU 的利用率，这个优势是毋庸置疑的。

3. 单线程顺序执行任务的方式比较符合编程人员按顺序思考的思维方式。但是串行执行的缺点在于性能，任何一个略慢的任务都会导致后续执行代码被阻塞。在计算机资源中，通常 I/O 与 CPU 计算之间是可以并行执行的。但是同步的编程模型导致的问题是，I/O 的进行会让后续任务等待，这造成资源不能被更好地利用。

4. 操作系统会将 CPU 的时间片分配给其余进程，以公平而有效地利用资源，基于这一点，有的服务器为了提升响应能力，会通过启动多个工作进程来为更多的用户服务。但是对于这一组任务而言，它无法分发任务到多个进程上，依然无法高效利用资源，结束所有任务所需的时间将较长。

5. 单线程同步编程模型会因阻塞 I/O 导致硬件资源得不到更优的利用。多线程编程模型因为编程中的死锁、状态同步等问题让开发人员头疼。Node 的解决方案是：利用单线程，远离多线程死锁、状态同步等问题，利用异步 I/O，让单线程远离阻塞，更好地利用 CPU。

6. 为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 WebWorkers 的子进程，该子进程可以通过工作进程高效的利用 CPU 的 I/O。

7. 操作系统内核对于I/O只有两种方式：阻塞和非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果。阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。非阻塞I/O和阻塞I/O的区别为调用之后会立即返回。非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务，此时的性能提升是明显的。

8. 非阻塞I/O存在的问题：由于完整的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。即轮询。
