# 深入浅出 NodeJS

## 第 3 章 异步 I/O

1. 业务场景中有一组互不相关的任务需要完成，现行的主流方法有以下两种：

   - 单线程串行依次执行
   - 多线程并行完成

2. 如果创建多线程的开销小于并行执行，那么多线程的方式是首选的。多线程的代价在于创建线程和执行期线程上下文切换的开销较大。另外在复杂的业务中，多线程编程经常面临锁、状态同步等问题，这是多线程被诟病的主要原因。但是多线程在多核 CPU 上能够有效提升 CPU 的利用率，这个优势是毋庸置疑的。

3. 单线程顺序执行任务的方式比较符合编程人员按顺序思考的思维方式。但是串行执行的缺点在于性能，任何一个略慢的任务都会导致后续执行代码被阻塞。在计算机资源中，通常 I/O 与 CPU 计算之间是可以并行执行的。但是同步的编程模型导致的问题是，I/O 的进行会让后续任务等待，这造成资源不能被更好地利用。

4. 操作系统会将 CPU 的时间片分配给其余进程，以公平而有效地利用资源，基于这一点，有的服务器为了提升响应能力，会通过启动多个工作进程来为更多的用户服务。但是对于这一组任务而言，它无法分发任务到多个进程上，依然无法高效利用资源，结束所有任务所需的时间将较长。

5. 单线程同步编程模型会因阻塞 I/O 导致硬件资源得不到更优的利用。多线程编程模型因为编程中的死锁、状态同步等问题让开发人员头疼。Node 的解决方案是：利用单线程，远离多线程死锁、状态同步等问题，利用异步 I/O，让单线程远离阻塞，更好地利用 CPU。

6. 为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 WebWorkers 的子进程，该子进程可以通过工作进程高效的利用 CPU 的 I/O。

7. 操作系统内核对于 I/O 只有两种方式：阻塞和非阻塞。在调用阻塞 I/O 时，应用程序需要等待 I/O 完成才返回结果。阻塞 I/O 的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。非阻塞 I/O 和阻塞 I/O 的区别为调用之后会立即返回。非阻塞 I/O 返回之后，CPU 的时间片可以用来处理其他事务，此时的性能提升是明显的。

8. 非阻塞 I/O 存在的问题：由于完整的 I/O 并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用 I/O 操作来确认是否完成。即轮询。

9. 现在的轮询技术主要有以下这些：

   - read: 它是最原始、性能最低的一种，通过重复调用来检查 I/O 的状态来完成完整数据的读取。在得到最终数据前，CPU 一直耗用在等待上。
   - select: 它是在 read 的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断。select 轮询具有一个较弱的限制，那就是由于它采用一个 1024 长度的数组来存储状态，所以它最多可以同时检查 1024 个文件描述符。
   - poll:该方案较 select 有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。
   - epoll: 该方案是 Linux 下效率最高的 I/O 事件通知机制，在进入轮询的时候如果没有检查到 I/O 事件，将会进行休眠，直到事件发生将其唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费 CPU，执行效率较高。
   - kqueue: 该方案的实现与 epoll 类似，不过它仅在 FreeBSD 系统下存在。

10. 理想的非阻塞异步 I/O：完美的异步 I/O 应该是应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需要在 I/O 完成后通过信号或回调将数据传递给应用程序即可。在 Linux 下存在一种原生的异步 I/O 方式，但是有缺陷，AIO 仅支持内核 I/O 中的 O_DIRECT 方式读取，导致无法利用系统缓存。

11. 在多线程情况下，通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，这就轻松实现了异步 I/O（尽管是模拟的）。

12. Node 的异步 I/O：在\*nix 系统中用自定义线程池实现，在 windows 中用 IOCP 实现。

13. Node 是单线程的，但仅仅只是 JS 执行在单线程中，无论是\*nix 还是 windows 平台，内部完成 I/O 任务的另有线程池。

14. 事件循环：Node 自身的执行模型是事件循环，在进程启动时，Node 便会创建一个类似于 while(true)的循环，每执行一次循环体的过程我们成为 Tick。每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。

15. 在 Node 中，事件主要来源于网络请求、文件 I/O 等，这些事件对应的观察者有文件 I/O 观察者、网络 I/O 观察者等。观察者将事件进行了分类。

16. 事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求等则是事件的生产者，源源不断为 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。

17. 非 I/O 的异步 API：setTimeout(), setInterval(), setImmediate(), process.nextTick()

18. 服务器模型：

    1. 同步式：对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态。
    2. 每进程/每请求：为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多。
    3. 每线程/每请求：为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存很快用光，导致服务器缓慢。

19. 事件驱动：Node 通过事件驱动的方式处理请求，无须为每个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是 Node 高性能的一个原因。
