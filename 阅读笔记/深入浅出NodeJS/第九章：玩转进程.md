# 深入浅出 NodeJS

## 第 9 章 玩转进程

1. 服务模型的变迁：
   1. 同步：最早的服务器，执行模型是同步的，服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。
   2. 复制进程：为了解决同步架构的并发问题，一个简单的改进就是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，代价非常高。在进程复制的过程中，需要复制进程内部的状态，对每个连接都进行这二样的复制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据，启动是比较慢的。
   3. 多线程：为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。
   4. 事件驱动：为了解决高并发问题，基于事件驱动的服务模型出现了，Node与Nginx均是基于事件驱动的方式实现的，采用单线程避免了不必要的内存开销和上下文切换开销。

2. Master-Worker模式：主从模式。主进程和工作进程。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋于稳定的。工作进程负责具体的业务处理。
3. 进程间通信：Node中实现IPC通道的是管道（pipe）技术。具体细节实现由libuv提供，在windows下由命名管道实现，*nix系统则采用Unix Domain Socket实现。表现在应用层上的进程间通信只有简单的message事件和send()方法。父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出紫禁城，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。
