# 深入浅出 NodeJS

## 第 2 章 模块机制

1. 过去的 JavaScript 存在的缺陷：

   1. 没有模块系统
   2. 标准库较少。ECMAScript 仅定义了部分核心库，对于文件系统，I/O 流等常见需求却没有标准的 API。
   3. 没有标准接口。在 JavaScript 中，几乎没有定义过如 Web 服务器或者数据库之类的标准统一接口。
   4. 缺乏包管理系统。这导致 JavaScript 应用中基本没有自动加载和安装依赖的能力。

2. CommonJS 对模块的定义十分简单，主要分为模块引用、模块定义和模块标识 3 个部分。

   1. 在 CommonJS 规范中，存在 require()方法，这个方法接受模块标识，以此引入一个模块的 API 到当前上下文中。
   2. 上下文提供了 exports 对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个 module 对象，它代表模块自身，而 exports 是 module 的属性。在 Node 中，一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式。
   3. 模块标识就是传递给 require()方法的参数，它必须是符合小驼峰命名的字符串，或相对路径，或绝对路径。

3. CommonJS 构建的这套模块导出和引入机制使得用户完全不必考虑变量污染。

4. 在 Node 中引入模块，需要经历 3 个步骤：

   1. 路径分析
   2. 文件定位
   3. 编译执行

5. 在 Node 中，模块分为两类：一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

   1. 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就直接被加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
   2. 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

6. 优先从缓存加载：与前端浏览器会缓存静态脚本文件以提高性能一样，Node 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而 Node 缓存的是编译和执行之后的对象。不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

7. 路径分析和文件定位：对于不同的标识符，模块的查找和定位有不同程度上的差异。

   1. 模块标识符分析：
      - 核心模块，如 http, fs, path 等：核心模块的优先级仅次于缓存加载，它在 Node 的源代码编译过程中已经编译为二进制代码，其加载过程最快。
      - `.`或`..`开始的相对路径文件模块：相对路径和绝对路径都被当作文件模块来处理，分析文件模块时`require()`方法会将路径转为真实路径，并以真是路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。由于文件模块给 Node 指明了确切的文件为止，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。
      - 以`/`开始的绝对路径文件模块
      - 非路径形式的文件模块：非核心模块，也不是路径形式的标识符，它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。
   2. 文件定位：从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。
      - 文件扩展名分析：`require()`在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS 模块规范也允许在标识符中不含文件扩展名，这种情况下，Node 会按`.js, .json, .node`的次序补足扩展名，依次尝试。在尝试的过程中，需要调用 fs 模块同步阻塞地判断文件是否存在。因为 Node 是单线程的，所以这里是一个会引起性能问题的地方。可以通过带扩展名传递给`require()`，会加快一点速度。也可以同步配合缓存，大幅度缓解 Node 单线程中阻塞式调用的缺陷。
      - 目录分析和包：在分析标识符的过程中，`require()`通过分析文件扩展名之后，可能没有查找到对应文件，但却得到了一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时 Node 会将目录当作一个包来处理。Node 通过解析`package.json`中 main 字段解析出入口文件，如果 main 字段指定错误，或者没有 package.json 文件，Node 会将 index 当做默认文件名，然后依次查找 index.js、index.json、index.node。
   3. 模块编译：在 Node 中，每个文件模块都是一个对象。编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node 会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同：
      1. `.js`文件：通过 fs 模块同步读取文件后编译执行
      2. `.node`文件：这是用 C/C++编写的扩展文件，其载入方法也有所不同，通过 dlopen()方法加载最后编译生成的文件
      3. `.json`文件：通过 fs 模块同步读取文件后，用`JSON.parse()`解析返回结果
      4. 其余扩展名文件：都被当做.js 文件载入。
      5. 每一个编译成功的模块都会将其文件路径作为索引缓存在 Module.\_cache 对象上，以提高二次引入的性能。

8. 模块路径的生成规则：文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。

   - 当前文件目录下的 node_modules 目录
   - 父目录下的 node_modules 目录
   - 父目录的父目录下的 node_modules 目录
   - 沿路径向上逐级递归，直到根目录下的 node_modules 目录

9. 核心模块：Node 的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块其实分为 C/C++编写的和 JavaScript 编写的两部分，其中 C/C++文件存放在 Node 项目的 src 目录下，JavaScript 文件存放在 lib 目录下。
