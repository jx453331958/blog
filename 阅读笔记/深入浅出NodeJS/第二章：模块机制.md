# 深入浅出 NodeJS

## 第 2 章 模块机制

1. 过去的 JavaScript 存在的缺陷：

   1. 没有模块系统
   2. 标准库较少。ECMAScript 仅定义了部分核心库，对于文件系统，I/O 流等常见需求却没有标准的 API。
   3. 没有标准接口。在 JavaScript 中，几乎没有定义过如 Web 服务器或者数据库之类的标准统一接口。
   4. 缺乏包管理系统。这导致 JavaScript 应用中基本没有自动加载和安装依赖的能力。

2. CommonJS 对模块的定义十分简单，主要分为模块引用、模块定义和模块标识 3 个部分。

   1. 在 CommonJS 规范中，存在 require()方法，这个方法接受模块标识，以此引入一个模块的 API 到当前上下文中。
   2. 上下文提供了 exports 对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个 module 对象，它代表模块自身，而 exports 是 module 的属性。在 Node 中，一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式。
   3. 模块标识就是传递给 require()方法的参数，它必须是符合小驼峰命名的字符串，或相对路径，或绝对路径。

3. CommonJS 构建的这套模块导出和引入机制使得用户完全不必考虑变量污染。

4. 在 Node 中引入模块，需要经历 3 个步骤：

   1. 路径分析
   2. 文件定位
   3. 编译执行

5. 在 Node 中，模块分为两类：一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

   1. 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就直接被加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
   2. 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

6. 优先从缓存加载：与前端浏览器会缓存静态脚本文件以提高性能一样，Node 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而 Node 缓存的是编译和执行之后的对象。不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

7. 路径分析和文件定位：对于不同的标识符，模块的查找和定位有不同程度上的差异。
   1. 模块标识符分析：
