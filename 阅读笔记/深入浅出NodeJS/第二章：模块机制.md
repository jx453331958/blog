# 深入浅出 NodeJS

## 第 2 章 模块机制

1. 过去的 JavaScript 存在的缺陷：

   1. 没有模块系统
   2. 标准库较少。ECMAScript 仅定义了部分核心库，对于文件系统，I/O 流等常见需求却没有标准的 API。
   3. 没有标准接口。在 JavaScript 中，几乎没有定义过如 Web 服务器或者数据库之类的标准统一接口。
   4. 缺乏包管理系统。这导致 JavaScript 应用中基本没有自动加载和安装依赖的能力。

2. CommonJS 对模块的定义十分简单，主要分为模块引用、模块定义和模块标识 3 个部分。

   1. 在 CommonJS 规范中，存在 require()方法，这个方法接受模块标识，以此引入一个模块的 API 到当前上下文中。
   2. 上下文提供了 exports 对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个 module 对象，它代表模块自身，而 exports 是 module 的属性。在 Node 中，一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式。
   3. 模块标识就是传递给 require()方法的参数，它必须是符合小驼峰命名的字符串，或相对路径，或绝对路径。

3. CommonJS 构建的这套模块导出和引入机制使得用户完全不必考虑变量污染。

4. 在 Node 中引入模块，需要经历 3 个步骤：

   1. 路径分析
   2. 文件定位
   3. 编译执行

5. 在 Node 中，模块分为两类：一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

   1. 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就直接被加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
   2. 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

6. 优先从缓存加载：与前端浏览器会缓存静态脚本文件以提高性能一样，Node 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而 Node 缓存的是编译和执行之后的对象。不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

7. 路径分析和文件定位：对于不同的标识符，模块的查找和定位有不同程度上的差异。

   1. 模块标识符分析：
      - 核心模块，如 http, fs, path 等：核心模块的优先级仅次于缓存加载，它在 Node 的源代码编译过程中已经编译为二进制代码，其加载过程最快。
      - `.`或`..`开始的相对路径文件模块：相对路径和绝对路径都被当作文件模块来处理，分析文件模块时`require()`方法会将路径转为真实路径，并以真是路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。由于文件模块给 Node 指明了确切的文件为止，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。
      - 以`/`开始的绝对路径文件模块
      - 非路径形式的文件模块：非核心模块，也不是路径形式的标识符，它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。
   2. 文件定位：从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。
      - 文件扩展名分析：`require()`在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS 模块规范也允许在标识符中不含文件扩展名，这种情况下，Node 会按`.js, .json, .node`的次序补足扩展名，依次尝试。在尝试的过程中，需要调用 fs 模块同步阻塞地判断文件是否存在。因为 Node 是单线程的，所以这里是一个会引起性能问题的地方。可以通过带扩展名传递给`require()`，会加快一点速度。也可以同步配合缓存，大幅度缓解 Node 单线程中阻塞式调用的缺陷。
      - 目录分析和包：在分析标识符的过程中，`require()`通过分析文件扩展名之后，可能没有查找到对应文件，但却得到了一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时 Node 会将目录当作一个包来处理。Node 通过解析`package.json`中 main 字段解析出入口文件，如果 main 字段指定错误，或者没有 package.json 文件，Node 会将 index 当做默认文件名，然后依次查找 index.js、index.json、index.node。
   3. 模块编译：在 Node 中，每个文件模块都是一个对象。编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node 会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同：
      1. `.js`文件：通过 fs 模块同步读取文件后编译执行
      2. `.node`文件：这是用 C/C++编写的扩展文件，其载入方法也有所不同，通过 dlopen()方法加载最后编译生成的文件
      3. `.json`文件：通过 fs 模块同步读取文件后，用`JSON.parse()`解析返回结果
      4. 其余扩展名文件：都被当做.js 文件载入。
      5. 每一个编译成功的模块都会将其文件路径作为索引缓存在 Module.\_cache 对象上，以提高二次引入的性能。

8. 模块路径的生成规则：文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。

   - 当前文件目录下的 node_modules 目录
   - 父目录下的 node_modules 目录
   - 父目录的父目录下的 node_modules 目录
   - 沿路径向上逐级递归，直到根目录下的 node_modules 目录

9. 核心模块：Node 的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块其实分为 C/C++编写的和 JavaScript 编写的两部分，其中 C/C++文件存放在 Node 项目的 src 目录下，JavaScript 文件存放在 lib 目录下。

10. JavaScript 核心模块的编译过程：

    1. 转存为 C/C++代码：Node 采用了 V8 附带的 js2c.py 工具，将所有内置的 JavaScript 代码（src/node.js 和 lib/\*.js）转换成 C++里的数组，生成 node_natives.h 头文件。在这个过程中，JavaScript 代码以字符串的形式存储在 node 命名空间中，是不可直接执行的。在启动 Node 进程时，JavaScript 代码直接加载进内存中。在加载的过程中，JavaScript 核心模块经历标识符分析后直接定位到内存中，比普通文件模块从磁盘中一处一处查找要快很多。
    2. 编译 JavaScript 核心模块：lib 目录下的所有模块文件也没有定义 require、module、exports 这些变量。在引入 JavaScript 核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了 exports 对象。与文件模块有区别的地方在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置。

11. C/C++核心模块的编译过程：在核心模块中，有些模块全部由 C/C++编写，有些模块则由 C/C++完成核心部分，其他部分则由 JavaScript 实现包装或向外导出，以满足性能需求。后面这种 C++模块主内完成核心，JavaScript 主外实现封装的模式是 Node 能够提高性能的常见方式。由纯 C/C++编写的部分统一称为内建模块，因为它们通常不被用户直接调用。

    1. 内建模块的组织形式：每一个内建模块在定义之后，都通过 NODE_MODULE 宏将模块定义到 node 命名空间中，模块的具体初始化方法挂在为结构的 register_func 成员。内建模块的优势在于，首先它们本身由 C/C++编写，性能上优于脚本语言，其次在进行文件编译时，它们被编译进二进制文件。一旦 Node 开始执行，它们被直接加载进内存中，无需再次做标识符定位、文件定位、编译等过程，直接就可执行。
    2. 内建模块的导出：通常不推荐文件模块直接调用内建模块，如需调用直接调用核心模块即可，因为核心模块中基本都封装了内建模块。Node 在启动时，会生成一个全局变量 process，并提供 Binding()方法来协助加载内建模块。在加载内建模块时，先创建一个 exports 空对象，然后调用 get_builtin_module()方法取出内建模块，通过执行 register_func()填充 exports 对象，最后将 exports 对象按模块名缓存，并返回给调用方完成导出。

12. C/C++扩展模块与 JavaScript 模块的区别在于加载后不需要编译，直接执行之后就可以被外部调用了，其加载速度比 JavaScript 略快。使用 C/C++扩展模块的一个好处在于可以更灵活和动态地加载它们，保持 Node 模块自身简单性的同时，给予 Node 无限的可扩展性。

13. JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要。

14. 
