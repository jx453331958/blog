# 深入浅出 NodeJS

## 第 5 章 内存控制

1. V8 的对象分配：在 V8 中，所有的 JavaScript 对象都是通过堆来进行分配的。

2) 程序的内存分配：一个由 C/C++编译的程序占用的内存分为以下几个部分
   1. 栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
   2. 堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表
   3. 全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放
   4. 文字常量区：常量字符串就是放在这里的。 程序结束后由系统释放
   5. 程序代码区：存放函数体的二进制代码。

3. 当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制为止。

4. V8 主要的垃圾回收算法：V8 的垃圾回收策略主要基于分代式垃圾回收机制。在自动垃圾回收的演变过程中，没有一种垃圾回收算法能够胜任所有的场景。因为在实际的应用中，对象的生存周期长短不一，不同的算法只能针对特定情况具有最好的效果。为此，统计学在垃圾回收算法的发展中产生了较大的作用，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别堆不同分代的内存施以更高效的算法。V8 中，主要将对象分为新生代和老生代两代。

5. 从 V8 的自动垃圾回收机制的设计角度可以看到，V8 对内存使用进行限制的缘由。新生代设计为一个较小的内存空间是合理的，而老生代空间过大对于垃圾回收并无特别意义。V8 对内存限制的设置对于 Chrome 浏览器这种每个选项卡页面使用一个 V8 实例而言，内存的使用是绰绰有余的。

6. 函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域将会销毁。同时作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁。只被局部变量引用的对象存活周期较短。

7. Javascript 在执行时会去查找该变量定义在哪里。它最先查找的是当前作用域，如果在当前作用域中无法找到该变量的声明，将会向上级的作用域里查找，知道查到为止。

8. 实现外部作用域访问内部作用域中变量的方法叫做闭包。闭包的问题在于，一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。

9. 在正常的 Javascript 执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。
10. 查看内存使用情况：`process.memoryUsage()`，os 模块的`totalmem()`和`freemem()`方法也可以查看内存使用情况。
11. Buffer 对象的内存不由 V8 分配。
12. 内存泄漏的原因：

    1. 缓存
    2. 队列消费不及时
    3. 作用域未释放

13. 如何使用大量缓存：目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响 Node 进程的性能。在 Node 中主要解决两个问题：
    1. 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。
    2. 进程之间可以共享缓存。

14. 在Node中，不可避免的还是会存在操作大文件的场景。由于Node的内存限制，操作大文件也需要小心，Node提供了stream模块用于处理大文件。
