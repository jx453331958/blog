# 现代操作系统

## 第 1 章 引论

1. 现代计算机系统由一个或多个处理器、内存、磁盘、打印机、键盘、鼠标、显示器、网络接口以及各种其他输入/输出设备组成。
2. 操作系统的任务是为用户程序提供一个更好、更简单、更清晰的计算机模型，并管理上述设备。
3. 用户与操作系统交互的程序，基于文本的通常成为 shell，而基于图标的则成为图形用户界面（GUI）。
4. 多数计算机有两种运行模式：内核态和用户态。
5. 软件中最基础的部分是操作系统，它运行在内核态。在这个模式中，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在用户态下。在用户态下，只使用了机器指令中的一个子集。
6. 资源管理包括用以下两种不同方式实现多路复用（共享）资源：在时间上复用和在空间上复用。
    - 在时间上复用：不同的程序或用户轮流使用它。例如若系统中只有一个 CPU，而多个程序需要在该 CPU 上运行，操作系统则首先把该 CPU 分配给某一个程序，在他运行足够长的时间之后，另一个程序得到 CPU，然后是下一个，如此进行下去，最终，轮到第一个程序再次运行。
    - 空间复用：每个客户都得到资源的一部分，从而取代了客户排队。例如，通常在若干运行程序之间分割内存，这样每一个运行程序都可同时入住内存。假设有足够的内存可以存放多个程序，那么在内存中同时存放若干个程序的效率，比把所有内存都分给一个程序的效率要高得多。有关空间复用的其他资源还有磁盘。
7. 操作系统的历史：
    1. 第一代：真空管和穿孔卡片
    2. 第二代：晶体管和批处理程序
    3. 第三代：集成电路芯片和多道程序设计
    4. 第四代：个人计算机
8. 计算机硬件：
    1. CPU：从内存中取出指令并执行。在每个 CPU 基本周期中，首先从内存取出指令，解码以确定其类型和操作数，接着执行，然后取指、解码并执行下一条命令。
        - 每个 CPU 都有一套可执行的专门指令集。
        - CPU 内部有用来保存关键变量和临时数据的寄存器。
        - 程序计数器寄存器：保存了将要取出的下一条指令的内存地址，在指令取出之后，程序计数器就被更新以便指向后继的指令。
        - 堆栈指针寄存器：指向内存中当前栈的顶端。保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。
        - 程序状态字寄存器：这个寄存器包含了条件码位、CPU 优先级、模式（用户态或内核态），以及各种其他控制位。
        - 流水线设计，CPU 具有同时取出多条指令的机制：一个 CPU 可以有分开的取指单元、解码单元和执行单元，于是当它执行指令 n 时，它还可以对指令 n+1 解码，并且读取指令 n+2。
        - 超标量 CPU，比流水线更先进的设计：在这种设计中，拥有多个执行单元，例如一个 CPU 用于整数算术运算，一个 CPU 用于浮点算术运算，另一个用于布尔运算。两个或更多的指令被同时取出、解码并装入一个保持缓冲区中，直至它们执行完毕。
    2. 存储器：存储器系统采用一种分层次的结构，寄存器、高速缓存、内存、磁盘、磁带，顶层的存储器速度较高，容量较小，与底层的存储器相比每位成本较高。
        - 存储器系统的顶层是 CPU 中的寄存器。它们用与 CPU 相同的材料制成，所以和 CPU 一样快。
        - 下一层是高速缓存，它多数由硬件控制。
        - 主存：通常被成为随机访问存储器（RAM）
        - 非易失性随机访问存储器：在电源切断之后，不会丢失内容，ROM
        - EEPROM：电可擦除可编程 ROM。
        - 磁盘：磁盘同 RAM 相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了三个数量级。其低速的原因是磁盘是一种机械装置。每个磁道划分为若干个扇区，扇区的典型值是 512 字节。
        - 上下文切换：在多道程序系统中，从一个程序切换到另一个程序。
        - 磁带：在存储器体系中的最后一层是磁带。这种介质用于磁盘备份，可以保存非常大量的数据集。
    3. I/O 设备：
        - I/O 设备一般包括两个部分：设备控制器和设备本身。控制器是插在电路板上的一块芯片或一组芯片，这块电路板物理地控制设备。它从操作系统接收命令。
        - 实现输入和输出的方式有三种。
            1. 忙等待：用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。缺点是要占据 CPU，CPU 一直轮询设备直到对应的 I/O 操作完成。
            2. 设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。
            3. 第三种方式：为 I/O 使用一种特殊的直接存储器访问（DMA）芯片，它可以控制在内存和某些控制器之间的位流，而无须持续的 CPU 干预。
        - 中断向量：设备编号可以成为部分内存的一个引用，用于寻找该设备中断处理程序的地址，这部分内存称为中断向量。
    4. 总线:
        1. 通用串行总线（USB）：用来将所有慢速 IO 设备，例如键盘和鼠标，与计算机连接。
        2. SCSI：是一种高速总线，用在高速硬盘、扫描仪和其他需要较大宽带的设备上。
9. 操作系统分类：
    1. 大型机操作系统
    2. 服务器操作系统
    3. 多处理器操作系统
    4. 个人计算机操作系统
    5. 掌上计算机操作系统
    6. 嵌入式操作系统
    7. 传感器节点操作系统
    8. 实时操作系统：特征是将时间作为关键参数
    9. 智能卡操作系统
10. 操作系统概念：

    1. 进程：进程本质上是正在执行的一个程序。
        1. 地址空间：与每个进程相关的是地址空间，这是从某个最小值的存储位置到某个最大值存储位置的列表。
        2. 在地址空间中，进程可以进行读写。
        3. 该地址空间中存放有可执行程序、程序的数据以及程序的堆栈。
        4. 与每个进程相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针）、打开文件的清单、突出的报警、有关进程清单，以及运行该程序所需要的其他所有信息。
        5. 进程表：与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为进程表，进程表是数组或链表结构。
        6. 进程间通信：合作完成某些作业的相关进程经常需要彼此通信以便同步他们的行为。
    2. 地址空间：每个进程有一些可以使用的地址集合，典型值从 0 开始直到某个最大值。在最简单的情形下，一个进程可拥有的最大地址空间小于主存。在这种方式下，进程可以用满其地址空间，而且内存中也有足够的空间容纳其他进程。
    3. 文件：操作系统的一项主要功能是隐藏磁盘和其他 IO 设备的细节特性，并提供给程序员一个良好、清晰的独立于设备的抽象文件模型。

11. 操作系统结构：
    1. 单体系统：全部操作系统在内核态中以单一程序的方式运行。整个操作系统以过程集合的方式编写，链接成一个大型可执行二进制程序。
    2. 层次式系统：共分为六层，操作员、用户程序、输入/输出管理、操作员-进程通信、存储器和磁鼓管理、处理器分配和多道程序设计。
    3. 微内核
    4. 客户机-服务器模式
    5. 虚拟机
    6. 外核

## 第 2 章 进程与线程

1. 进程：

    1. 在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干个顺序进程，简称进程。
    2. 一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。
    3. 一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。
    4. 单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而向另一个进程提供服务。
    5. 创建进程：
        1. 系统初始化
        2. 执行了正在运行的进程所调用的进程创建系统调用
        3. 用户请求创建一个新进程
        4. 一个批处理作业的初始化
    6. 守护进程：停留在后台处理诸如电子邮件、web 页面、新闻、打印之类的活动的进程称为守护进程。
    7. 在 UNIX 系统中，只有一个系统调用可以用来创建新进程：fork。在调用了 fork 之后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件。
    8. 在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。
    9. 进程的终止：
        1. 正常退出（自愿的）
        2. 出错退出（自愿的）
        3. 严重错误（非自愿）
        4. 被其他进程杀死（非自愿）：系统调用是 kill
    10. 多数进程是由于完成了它们的工作而终止。当编译器完成了所给定程序的编译之后，编译器执行一个系统调用，通知操作系统它的工作已经完成。在 UNIX 中该调用是 exit
    11. 进程的层次结构：某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建出更多的进程，组成一个进程的层次结构。进程只有一个父进程，但可以有零个、一个或多个子进程。
    12. 在 UNIX 中，进程和它的所有子女及后裔共同组成一个进程组。
    13. 进程的三种状态：
        1. 运行态（该时刻进程实际占用 CPU）
        2. 就绪态（可运行，但因为其他进程正在运行而暂时停止）
        3. 阻塞态（除非某种外部事件发生，否则进程不能运行）
    14. 调度程序的主要工作就是决定应当运行哪个进程、何时运行及它应该运行多长时间。
    15. 进程的实现：
        1. 为了实现进程模型，操作系统维护着一张表格（一个结构数组）即进程表。
        2. 每个进程占用一个进程表项，该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行状态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未中断过一样。
        3. 典型的进程表表项中的一些字段：
            1. 进程管理：寄存器、程序计数器、程序状态字、堆栈指针、进程状态、优先级、调度参数、进程 ID、父进程、进程组、信号、进程开始时间、使用的 CPU 时间、子进程的 CPU 时间、下次报警时间。
            2. 存储管理：正文段指针、数据段指针、堆栈段指针。
            3. 文件管理：根目录、工作目录、文件描述符、用户 ID、组 ID。
        4. 与每一 IO 类关联的是一个称作中断向量的位置。它包含中断服务程序的入口地址。
    16. 多道程序设计模型：采用多道程序设计可以提高 CPU 的利用率。

2. 线程：

    1. 在有了多线程模型之后，有了一种新的元素：并行实体共享同一个地址空间和所有可用数据的能力。对于某些应用而言，这种能力是必须的，而这正是多进程模型（它们具有不同地址空间）所无法表达的。
    2. 由于线程比进程更轻量级，所以它们比进程更容易（更快）创建也更容易撤销。在许多系统中，创建一个线程比创建一个进程要快 10 ～ 100 倍。
    3. 分派线程：

        ```c
        while(TRUE) {
            get_next_request(&buf);
            handoff_work(&buf);
        }
        ```

    4. 工作线程

        ```c
        while(TRUE) {
            wait_for_work(&buf)
            look_for_page_in_cache(&buf, &page);
            if (page_not_in_cache(&page))
                read_page_from_disk(&buf, &page);
            return_page(&page)
        }
        ```

    5. 有限状态机：每个计算都有一个倍保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，这类设计称为有限状态机。
    6. 构造服务器的三种模型：
        1. 多线程：并行性、阻塞系统调用
        2. 单线程进程：无并行性、阻塞系统调用
        3. 有限状态机：并行性、非阻塞系统调用、中断
    7. 经典的线程模型：
        1. 进程模型基于两种独立的概念：资源分组处理与执行。
        2. 进程有存放程序正文和数据以及其他资源的地址空间。这些资源包括打开的文件、子进程、即将发生的报警、信号处理程序、账号的信息等。
        3. 进程拥有一个执行的线程，通常简写为线程。
        4. 在线程中有一个程序计数器，用来记录接着要执行哪一条指令。
        5. 线程拥有寄存器，用来保存线程当前的工作变量。
        6. 线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用但是还没有从中返回的过程。
        7. 线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。
        8. 多线程这个术语，用来描述在同一个进程中允许多个线程的情形。
        9. 进程中的不同线程不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。
        10. 线程的状态：运行、阻塞、就绪或终止。
    8. POSIX线程
    9. 在用户空间中实现线程：有两种主要的方法实现线程包，在用户空间和在内核中。第一种方法是把整个线程包放在用户空间中，内核对线程包一无所知。
    10. 在用户空间管理线程时，每个进程需要有其专用的线程表，用来跟踪该进程中的线程。这些表和进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈、指针、寄存器和状态等。该线程表由运行时系统管理。
    11. 在内核中实现线程：不再需要运行时系统了，每个进程中也没有线程表。相反，在内核中有用来记录系统中所有线程的线程表。
    12. 当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程的创建或撤销工作。
    13. 内核的线程表保存了每个线程的寄存器、状态和其他信息。
    14. 在内核中实现线程，所有能够阻塞线程的调用都以系统调用的形式实现，与运行时系统相比，代价更小。
    15. 在内核中创建或撤销线程的代价比较大，更好的处理方式是回收。
    16. 内核级线程在一些关键点上优于用户级线程，但是内核级线程的速度慢。
    17. 调度程序激活机制
    18. 弹出式线程

3. 进程间通信：
   1. 竞争条件：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。
   2. 怎样避免竞争条件：互斥，以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。
   3. 临界区：我们把对共享内存进行访问的程序片段称作临界区。如果我们能够适当安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。
   4. 一个好的解决方案需要满足下面4个条件：
      1. 任何两个进程不能同时处于临界区
      2. 不应对CPU的速度和数量做任何假设
      3. 临界区对运行的进程不得阻塞其他进程
      4. 不得使进程无限期等待进入临界区
