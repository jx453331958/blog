# 现代操作系统

## 第 3 章 存储管理

1. 操作系统中管理分层存储器体系的部分称为存储管理器。它的任务是有效地管理内存，即记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。

2. 无存储器抽象

    1. 一个没有内存抽象的系统也不太可能具有线程抽象的功能。
    2. 没有内存抽象，同时运行多个程序也是可能的。操作系统只需要把当前内存中的所有内容保存到磁盘文件中，然后把下一个程序读入到内存中再运行即可。只要在某一个时间内存中只有一个程序，那么就不会发生冲突。
    3. 需要避免两个程序都引用绝对物理地址。每个程序都应该使用一套私有的本地地址来进行内存寻址。

3. 一种存储器抽象：地址空间
    1. 把物理地址暴露给进程会带来几个严重的问题：
        1. 如果用户程序可以寻址内存的每个字节，它们就可以很容易地破坏操作系统，从而使系统慢慢地停止运行。
        2. 使用这种模型，想要同时运行多个程序是很困难的。
    2. 要保证多个应用程序同时处于内存中并且不互相影响，则需要解决两个问题：保护和重定位。
    3. 地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立语其他进程的地址空间。
    4. 基址寄存器与界限寄存器：这个简单的解决办法使用一种简单的动态重定位。它所做的是简单的把每个进程的地址空间映射到物理内存的不同部分。
    5. 当使用基址寄存器和界限寄存器时，程序装载到内存中连续的空间位置且装载期间无需重定位。每次一个进程访问内存，取一条指令，读或写一个数据字，CPU 硬件会把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。同时，它检查程序提供的地址是否等于或大于界限寄存器里的值，如果访问的地址超过了界限，会产生错误并终止访问。
    6. 使用基址寄存器和界限寄存器是给每个进程提供私有地址空间的非常容易的方法，因为每个内存地址在送到内存之前，都会自动先加上基址寄存器的内容。
    7. 使用基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加法和比较运算。比较可以做的很快，但是加法由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢。
    8. 交换技术：有两种处理内存超载的通用方法。
        1. 最简单的策略是交换技术，即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上，所以当它们不运行时不会占用内存。
        2. 另一种策略是虚拟内存，该策略甚至能使应用程序在只有一部分被调入内存的情况下运行。
    9. 内存紧缩：交换在内存中产生了多个空闲区，通过把所有的进程尽可能向下移动，有可能将这些小的空闲区合成一大块。该技术称为内存紧缩。
    10. 如果大部分进程在运行时都要增长，为了减少因内存区域不够而引起的进程交换和移动所产生的开销，一种可用的方法是，当换入或移动进程时为它分配一些额外的内存。然而，当进程换出到磁盘上时，应该只交换进程实际上使用的内存中的内容，将额外的内存交换出去是一种浪费。
    11. 空闲内存管理：在动态分配内存时，操作系统必须对其进行管理。一般而言，有两种方式跟踪内存使用情况：位图和空闲链表。
        1. 使用位图方法时，内存可能被划分成小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲，1 表示占用。
        2. 分配单元的大小是一个重要的设计因素。分配单元越小，位图越大。
        3. 使用链表管理内存时，链表的一个结点或者包含一个进程，或者是两个进程间的一个空的空闲区。
        4. 链表中的每一个结点都包含以下域：空闲区或进程的指示标志、起始地址、长度和指向下一个结点的指针。
    12. 虚拟内存：每个进程拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或页面。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。
    13. 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把 CPU 交给另一个进程使用。
    14. 分页：大部分虚拟内存系统中都使用一种称为分页的技术。
        1. 由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。
        2. 在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字。而在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元（Memory Management Unit, MMU），MMU 把虚拟地址映射为物理内存地址。
        3. 虚拟地址空间按照固定大小划分成称为页面的若干单元。在物理内存中对应的单元称为页框。页面和页框的大小通常是一样的。
        4. RAM 和磁盘之间的交换总是以整个页面为单元进行的。
        5. 缺页中断：MMU 在处理没有被映射的页面时，使 CPU 陷入到操作系统，这个陷阱常称为缺页中断。操作系统找到一个很少使用的页框且把它的内容写入磁盘。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。
        6. 页表：虚拟地址被分成虚拟页号(高位部分)和偏移量(地位部分)两部分。虚拟页号可用作页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号。然后把页框号拼接到偏移量的高端位，以替换掉虚拟页号，形成送往内存的物理地址。
        7. 页表的目的是把虚拟页面映射为页框。
        8. 虚拟内存本质上是用来创造一个新的抽象概念——地址空间，这个概念是对物理内存的抽象，类似于进程是对物理机器（CPU）的抽象。虚拟内存的实现，是将虚拟地址空间分解成页，并将每一页映射到物理内存的某个页框或者（暂时）解除映射。
        9. 在任何分页式系统中，都需要考虑两个主要问题：
            1. 虚拟地址到物理地址的映射必须非常快：由于每次访问内存，都需要进行虚拟地址到物理地址的映射。所有的指令最终来自内存，并且很多指令也会访问内存中的操作数。因此，每条指令进行多次页表访问是必要的，页表查询必须足够快，以避免映射成为一个主要瓶颈。
            2. 如果虚拟地址空间很大，页表也会很大：现代计算机使用至少 32 位的虚拟地址，而且 64 位变得越来越普遍。假设页长为 4KB，32 位的地址空间将有 100 万页，而 64 位则更多。如果虚拟地址空间中有 100 万页，那么页表必然有 100 万条表项。
        10. 对大而快速的页面映射的需求成为了构建计算机的重要约束。
        11. 针对大内存的页表：
            1. 多级页表
            2. 倒排页表
4. 页面置换算法：当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。如果要换出的页面被修改过，就必须把它写回磁盘以更新该页面在磁盘上的副本，如果该页面没有被修改过，那么它在磁盘上的副本已经是最新的，不需要回写。直接用调入的页面覆盖掉被淘汰的页面就可以了。
    1. 当发生缺页中断时，虽然可以随机地选择一个页面来置换，但是如果每次都选择不常使用的页面会提升系统的性能。如果一个被频繁使用的页面被置换出内存，很可能它在很短时间内又要被调入内存，这会带来不必要的开销。
    2. 最优页面置换算法：在缺页中断发生时，有些页面在内存中，其中有一个页面将很快被访问，其他页面则可能要到 10、100 或 1000 条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记。最优页面置换算法规定应该置换标记最大的页面。这个算法唯一的问题就是它是无法实现的，当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。
    3. 最近未使用页面置换算法：
        1. 为使操作系统能够收集有用的统计信息，在大部分具有虚拟内存的计算机中，系统为每一页面设置了两个状态位。当页面被访问时设置 R 位，当页面被写入时设置 M 位。
        2. 当发生缺页中断时，操作系统检查所有的页面并根据它们当前的 R 位和 M 位得值，将它们分为 4 类：
            - 没有被访问，没有被修改；
            - 没有被访问，已被修改；
            - 已被访问，没有被修改；
            - 已被访问，已被修改；
        3. NRU（最近未使用）算法随机地从编号最小的非空类中挑选一个页面淘汰。这个算法隐含的意思是，在最近一个时钟滴答中淘汰一个没有被访问的已修改页面比淘汰一个被频繁使用的“干净”页面好。NRU 主要优点是易于理解和能够有效地被实现，虽然性能不是最好的，但是已经够用了。
    4. 先进先出页面置换算法：由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最久进入的页面放在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面加入表尾。由于可能淘汰不常用的页面也可能淘汰常用的页面，很少使用纯粹的 FIFO 算法。
    5. 第二次机会页面置换算法：
        1. FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改，检查最老页面的 R 位，如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换。如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入一样，然后继续搜索。
        2. 第二次机会算法就是寻找一个最近的时钟间隔以来没有被访问过的页面。如果所有页面都被访问过了，该算法就简化为纯粹的 FIFO 算法。
    6. 时钟页面置换算法：
        1. 第二次机会算法是一个比较合理的算法，但它经常要在链表中移动页面，既降低了效率又不是很有必要。
        2. 一个更好的办法是把所有的页面都保存在一个类似钟面的环形链表中，一个表指针指向最老的页面。
        3. 当发生缺页中断时，算法首先检查表指针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表指针前移一个位置。如果 R 位是 1 就清除 R 位并把表针前移一个位置，重复这个过程直到找到了一个 R 位为 0 的页面为止。
    7. 最近最少使用页面置换算法：
        1. 在缺页中断发生时，置换未使用时间最长的页面。这个策略称为 LRU（最近最少使用）页面置换算法。
        2. LRU 在理论上是可实现的，但是代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是在每次访问内存时必须要更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。
    8. 用软件模拟 LRU
    9. 工作集页面置换算法
    10. 工作集时钟页面置换算法
    11. 小结：

|          算法           |          注释           |
| :---------------------: | :---------------------: |
|        最有算法         | 不可实现，但可用作基准  |
|  NRU（最近未使用）算法  |   LRU 的很粗糙的近似    |
|  FIFO（先进先出）算法   |    可能抛弃重要页面     |
|     第二次机会算法      |   比 FIFO 有很大改善    |
| LRU（最近最少使用）算法 |   很优秀，但很难实现    |
| NFU（最不经常使用）算法 |  LRU 的相对粗略的近似   |
|        老化算法         | 非常近似 LRU 的有效算法 |
|       工作集算法        |    实现起来开销很大     |
|     工作集时钟算法      |      好的有效算法       |

5. 分页系统中的设计问题

    1. 局部分配策略与全局分配策略：怎样在相互竞争的可运行进程之间分配内存
    2. 负载控制：一旦所有进程的组合工作集超出了内存容量，就可能发生颠簸。
    3. 页面大小：要确定最佳的页面大小需要在几个互相矛盾的因素之间进行权衡。
    4. 分离的指令空间和数据空间：大多数计算机只有一个地址空间，既存放程序也存放数据，如果地址空间足够大那么一切都好，然而地址空间通常太小了，这就使得对地址空间的使用出现困难。
    5. 共享页面：在大型多道程序设计系统中，几个不同用户同时运行同一个程序是很常见的，由于避免了在内存中有一个页面的两份副本，共享页面效率更高。这里存在一个问题，即不是所有的页面都适合共享。特别地，那些只读的页面可以共享，但是数据页面不能共享。
    6. 共享库：可以使用其他的粒度取代单个页面来实现共享。
        1. 现代操作系统中，有很多大型库被众多进程使用。
        2. 如果共享库中的一个函数因为修正一个 bug 被更新了，那么并不需要重新编译调用了这个函数的程序。旧的二进制文件仍然可以正常工作。
        3. 在编译共享库时，用一个特殊的编译选项告诉编译器，不要产生使用绝对地址的指令。相反，只能产生使用相对地址的指令。不论共享库被放置在虚拟地址空间的什么位置，这种指令都可以正确工作。
        4. 只使用相对便宜量的代码被称作位置无关代码。
    7. 内存映射文件：共享库实际上是一种更为通用的机制——内存映射文件的一个特例。
        1. 这种机制的思想是：进程可以通过发起一个系统调用，将一个文件映射到其虚拟地址空间的一部分。在多数实现中，在映射共享的页面时不会实际读入页面的内容，而是在访问页面时才会被每次一页地读入，磁盘文件则被当作后备存储。当进程退出或显式地解除文件映射时，所有被改动的页面会被写回到文件中。
        2. 内存映射文件提供了一种 I/O 的可选模型。可以把一个文件当作一个内存中的大字符数组来访问，而不用通过读写操作来访问这个文件。
        3. 如果两个或两个以上的进程同时映射了同一个文件，它们就可以通过共享内存来通信。
    8. 清除策略：
        1. 为保证有足够的空闲页框，很多分页系统有一个称为分页守护进程的后台进程，它在大多数时候睡眠，但定期被唤醒以检查内存的状态。如果空闲页框过少，分页守护进程通过预定的页面置换算法选择页面换出内存。如果这些页面装入内存后被修改过，则将它们写回磁盘。
        2. 一种实现清除策略的方法就是用一个双指针时钟。前指针由分页守护进程控制。当它指向一个脏页面时，就该把该页面写回磁盘，前指针向前移动。当它指向一个干净页面时，仅仅指针向前移动。后指针用于页面置换，就像标准时钟算法中一样。
    9. 虚拟内存接口
        1. 一些高级系统，程序员可以对内存映射进行控制，并可以通过非常规的方法来增强程序的行为。
        2. 允许程序员对内存映射进行控制的一个原因就是为了允许两个或者多个进程共享同一部分内存。
        3. 页面共享也可以用来实现高性能的消息传递系统。

6. 有关实现的问题
    1. 与分页有关的工作：
        1. 操作系统要在下面的四段时间里做与分页相关的工作：进程创建时，进程执行时，缺页中断时和进程终止时。
        2. 当在分页系统中创建一个新进程时，操作系统要确定程序和数据在初始化时有多大，并为它们创建一个页表。
        3. 操作系统还要在内存中为页表分配空间并对其进行初始化。当进程被换出时，页表不需要驻留在内存中，当进程运行时，它必须在内存中。
        4. 操作系统要在磁盘交换区中分配空间，以便在一个进程换出时在磁盘上有放置此进程的空间。
        5. 操作系统还要用程序正文和数据对交换区进行初始化，这样当新进程发生缺页中断时，可以调入需要的页面。
        6. 最后，操作系统必须把有关页表和磁盘交换区的信息储存在进程表中。
        7. 当调度一个进程执行时，必须为新进程重置 MMU，刷新 TLB，以清除以前的进程遗留的痕迹。
        8. 当缺页中断发生时，操作系统必须通过读硬件寄存器来确定是哪个虚拟地址造成了缺页中断。通过该信息，它要计算需要哪个页面，并在磁盘上对该页面进行定位。它必须找到合适的页框来存放新页面，必要时还要置换老的页面，然后把所需的页面读入页框。最后还要备份程序计数器，使程序计数器指向引起缺页中断的指令，并重新执行该指令。
        9. 当进程退出的时候，操作系统必须释放进程的页表、页面和页面在硬盘上占用的空间。如果某些页面是与其他进程共享的，当最后一个使用它们的进程终止的时候，才可以释放内存和磁盘上的页面。
    2. 缺页中断处理：缺页中断发生时的事件顺序如下：
        1. 硬件陷入内核，在堆栈中保存程序计数器。大多数机器将当前指令的各种状态信息保存在特殊的 CPU 寄存器中。
        2. 启动一个汇编代码例程保存通用寄存器和其他易失信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。
        3. 当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。
        4. 一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生。系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。
        5. 如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。
        6. 一旦页框“干净”后，操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行。
        7. 当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态。
        8. 恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。
        9. 调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。
        10. 该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过一样。
    3. 指令备份：当程序访问不再内存中的页面时，引起缺页中断的指令会半途停止并引发操作系统的陷阱。在操作系统取出所需页面后，它需要重新启动引起陷阱的指令。在某些计算机上，CPU 的设计者们提供了一种解决办法，就是通过使用一个隐藏的内部寄存器。在每条指令执行之前，把程序计数器的内容复制到该寄存器。这些机器可能会有第二个寄存器，用来提供哪些寄存器已经自动增加或者自动减少以及增减的数量等信息。通过这些信息，操作系统可以消除引起缺页中断的指令所造成的所有影响，并使指令可以重新开始执行。如果该信息不可用，那么操作系统就要找出所发生的问题从而设计来修复它。
    4. 锁定内存中的页面：如果分页算法是全局算法，包含 I/O 缓冲区的页面会有很小的机会被选中换出内存。如果一个 I/O 设备正处在对该页面进行 DMA 传输的过程之中，将这个页面移出会导致部分数据写入他们所属的缓冲区中，而部分数据被写入到最新装入的页面中。一种解决方法是锁住正在做 I/O 操作的内存中的页面以保证它不会被移出内存。锁住一个页面通常称为在内存中钉住页面。另一种方法是在内核缓冲区中完成所有的 I/O 操作，然后再将数据复制到用户页面。
    5. 后备存储
