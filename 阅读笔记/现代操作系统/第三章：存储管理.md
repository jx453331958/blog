# 现代操作系统

## 第 3 章 存储管理

1. 操作系统中管理分层存储器体系的部分称为存储管理器。它的任务是有效地管理内存，即记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。

2. 无存储器抽象

    1. 一个没有内存抽象的系统也不太可能具有线程抽象的功能。
    2. 没有内存抽象，同时运行多个程序也是可能的。操作系统只需要把当前内存中的所有内容保存到磁盘文件中，然后把下一个程序读入到内存中再运行即可。只要在某一个时间内存中只有一个程序，那么就不会发生冲突。
    3. 需要避免两个程序都引用绝对物理地址。每个程序都应该使用一套私有的本地地址来进行内存寻址。

3. 一种存储器抽象：地址空间
    1. 把物理地址暴露给进程会带来几个严重的问题：
        1. 如果用户程序可以寻址内存的每个字节，它们就可以很容易地破坏操作系统，从而使系统慢慢地停止运行。
        2. 使用这种模型，想要同时运行多个程序是很困难的。
    2. 要保证多个应用程序同时处于内存中并且不互相影响，则需要解决两个问题：保护和重定位。
    3. 地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立语其他进程的地址空间。
    4. 基址寄存器与界限寄存器：这个简单的解决办法使用一种简单的动态重定位。它所做的是简单的把每个进程的地址空间映射到物理内存的不同部分。
    5. 当使用基址寄存器和界限寄存器时，程序装载到内存中连续的空间位置且装载期间无需重定位。每次一个进程访问内存，取一条指令，读或写一个数据字，CPU 硬件会把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。同时，它检查程序提供的地址是否等于或大于界限寄存器里的值，如果访问的地址超过了界限，会产生错误并终止访问。
    6. 使用基址寄存器和界限寄存器是给每个进程提供私有地址空间的非常容易的方法，因为每个内存地址在送到内存之前，都会自动先加上基址寄存器的内容。
    7. 使用基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加法和比较运算。比较可以做的很快，但是加法由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢。
    8. 交换技术：有两种处理内存超载的通用方法。
        1. 最简单的策略是交换技术，即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上，所以当它们不运行时不会占用内存。
        2. 另一种策略是虚拟内存，该策略甚至能使应用程序在只有一部分被调入内存的情况下运行。
    9. 内存紧缩：交换在内存中产生了多个空闲区，通过把所有的进程尽可能向下移动，有可能将这些小的空闲区合成一大块。该技术称为内存紧缩。
    10. 如果大部分进程在运行时都要增长，为了减少因内存区域不够而引起的进程交换和移动所产生的开销，一种可用的方法是，当换入或移动进程时为它分配一些额外的内存。然而，当进程换出到磁盘上时，应该只交换进程实际上使用的内存中的内容，将额外的内存交换出去是一种浪费。
    11. 空闲内存管理：在动态分配内存时，操作系统必须对其进行管理。一般而言，有两种方式跟踪内存使用情况：位图和空闲链表。
        1. 使用位图方法时，内存可能被划分成小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲，1 表示占用。
        2. 分配单元的大小是一个重要的设计因素。分配单元越小，位图越大。
        3. 使用链表管理内存时，链表的一个结点或者包含一个进程，或者是两个进程间的一个空的空闲区。
        4. 链表中的每一个结点都包含以下域：空闲区或进程的指示标志、起始地址、长度和指向下一个结点的指针。
    12. 虚拟内存：每个进程拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或页面。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。
    13. 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把 CPU 交给另一个进程使用。
    14. 分页：大部分虚拟内存系统中都使用一种称为分页的技术。
        1. 由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。
        2. 在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字。而在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元（Memory Management Unit, MMU），MMU 把虚拟地址映射为物理内存地址。
        3. 虚拟地址空间按照固定大小划分成称为页面的若干单元。在物理内存中对应的单元称为页框。页面和页框的大小通常是一样的。
        4. RAM 和磁盘之间的交换总是以整个页面为单元进行的。
        5. 缺页中断：MMU 在处理没有被映射的页面时，使 CPU 陷入到操作系统，这个陷阱常称为缺页中断。操作系统找到一个很少使用的页框且把它的内容写入磁盘。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。
        6. 页表：虚拟地址被分成虚拟页号(高位部分)和偏移量(地位部分)两部分。虚拟页号可用作页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号。然后把页框号拼接到偏移量的高端位，以替换掉虚拟页号，形成送往内存的物理地址。
        7. 页表的目的是把虚拟页面映射为页框。
        8. 虚拟内存本质上是用来创造一个新的抽象概念——地址空间，这个概念是对物理内存的抽象，类似于进程是对物理机器（CPU）的抽象。虚拟内存的实现，是将虚拟地址空间分解成页，并将每一页映射到物理内存的某个页框或者（暂时）解除映射。
        9. 在任何分页式系统中，都需要考虑两个主要问题：
            1. 虚拟地址到物理地址的映射必须非常快：由于每次访问内存，都需要进行虚拟地址到物理地址的映射。所有的指令最终来自内存，并且很多指令也会访问内存中的操作数。因此，每条指令进行多次页表访问是必要的，页表查询必须足够快，以避免映射成为一个主要瓶颈。
            2. 如果虚拟地址空间很大，页表也会很大：现代计算机使用至少 32 位的虚拟地址，而且 64 位变得越来越普遍。假设页长为 4KB，32 位的地址空间将有 100 万页，而 64 位则更多。如果虚拟地址空间中有 100 万页，那么页表必然有 100 万条表项。
        10. 对大而快速的页面映射的需求成为了构建计算机的重要约束。
