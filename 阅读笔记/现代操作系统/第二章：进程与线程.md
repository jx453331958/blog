# 现代操作系统

## 第 2 章 进程与线程

1. 进程：

    1. 在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干个顺序进程，简称进程。
    2. 一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。
    3. 一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。
    4. 单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而向另一个进程提供服务。
    5. 创建进程：
        1. 系统初始化
        2. 执行了正在运行的进程所调用的进程创建系统调用
        3. 用户请求创建一个新进程
        4. 一个批处理作业的初始化
    6. 守护进程：停留在后台处理诸如电子邮件、web 页面、新闻、打印之类的活动的进程称为守护进程。
    7. 在 UNIX 系统中，只有一个系统调用可以用来创建新进程：fork。在调用了 fork 之后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件。
    8. 在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。
    9. 进程的终止：
        1. 正常退出（自愿的）
        2. 出错退出（自愿的）
        3. 严重错误（非自愿）
        4. 被其他进程杀死（非自愿）：系统调用是 kill
    10. 多数进程是由于完成了它们的工作而终止。当编译器完成了所给定程序的编译之后，编译器执行一个系统调用，通知操作系统它的工作已经完成。在 UNIX 中该调用是 exit
    11. 进程的层次结构：某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建出更多的进程，组成一个进程的层次结构。进程只有一个父进程，但可以有零个、一个或多个子进程。
    12. 在 UNIX 中，进程和它的所有子女及后裔共同组成一个进程组。
    13. 进程的三种状态：
        1. 运行态（该时刻进程实际占用 CPU）
        2. 就绪态（可运行，但因为其他进程正在运行而暂时停止）
        3. 阻塞态（除非某种外部事件发生，否则进程不能运行）
    14. 调度程序的主要工作就是决定应当运行哪个进程、何时运行及它应该运行多长时间。
    15. 进程的实现：
        1. 为了实现进程模型，操作系统维护着一张表格（一个结构数组）即进程表。
        2. 每个进程占用一个进程表项，该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行状态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未中断过一样。
        3. 典型的进程表表项中的一些字段：
            1. 进程管理：寄存器、程序计数器、程序状态字、堆栈指针、进程状态、优先级、调度参数、进程 ID、父进程、进程组、信号、进程开始时间、使用的 CPU 时间、子进程的 CPU 时间、下次报警时间。
            2. 存储管理：正文段指针、数据段指针、堆栈段指针。
            3. 文件管理：根目录、工作目录、文件描述符、用户 ID、组 ID。
        4. 与每一 IO 类关联的是一个称作中断向量的位置。它包含中断服务程序的入口地址。
    16. 多道程序设计模型：采用多道程序设计可以提高 CPU 的利用率。

2. 线程：

    1. 在有了多线程模型之后，有了一种新的元素：并行实体共享同一个地址空间和所有可用数据的能力。对于某些应用而言，这种能力是必须的，而这正是多进程模型（它们具有不同地址空间）所无法表达的。
    2. 由于线程比进程更轻量级，所以它们比进程更容易（更快）创建也更容易撤销。在许多系统中，创建一个线程比创建一个进程要快 10 ～ 100 倍。
    3. 分派线程：

        ```c
        while(TRUE) {
            get_next_request(&buf);
            handoff_work(&buf);
        }
        ```

    4. 工作线程

        ```c
        while(TRUE) {
            wait_for_work(&buf)
            look_for_page_in_cache(&buf, &page);
            if (page_not_in_cache(&page))
                read_page_from_disk(&buf, &page);
            return_page(&page)
        }
        ```

    5. 有限状态机：每个计算都有一个倍保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，这类设计称为有限状态机。
    6. 构造服务器的三种模型：
        1. 多线程：并行性、阻塞系统调用
        2. 单线程进程：无并行性、阻塞系统调用
        3. 有限状态机：并行性、非阻塞系统调用、中断
    7. 经典的线程模型：
        1. 进程模型基于两种独立的概念：资源分组处理与执行。
        2. 进程有存放程序正文和数据以及其他资源的地址空间。这些资源包括打开的文件、子进程、即将发生的报警、信号处理程序、账号的信息等。
        3. 进程拥有一个执行的线程，通常简写为线程。
        4. 在线程中有一个程序计数器，用来记录接着要执行哪一条指令。
        5. 线程拥有寄存器，用来保存线程当前的工作变量。
        6. 线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用但是还没有从中返回的过程。
        7. 线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。
        8. 多线程这个术语，用来描述在同一个进程中允许多个线程的情形。
        9. 进程中的不同线程不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。
        10. 线程的状态：运行、阻塞、就绪或终止。
    8. POSIX 线程
    9. 在用户空间中实现线程：有两种主要的方法实现线程包，在用户空间和在内核中。第一种方法是把整个线程包放在用户空间中，内核对线程包一无所知。
    10. 在用户空间管理线程时，每个进程需要有其专用的线程表，用来跟踪该进程中的线程。这些表和进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈、指针、寄存器和状态等。该线程表由运行时系统管理。
    11. 在内核中实现线程：不再需要运行时系统了，每个进程中也没有线程表。相反，在内核中有用来记录系统中所有线程的线程表。
    12. 当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程的创建或撤销工作。
    13. 内核的线程表保存了每个线程的寄存器、状态和其他信息。
    14. 在内核中实现线程，所有能够阻塞线程的调用都以系统调用的形式实现，与运行时系统相比，代价更小。
    15. 在内核中创建或撤销线程的代价比较大，更好的处理方式是回收。
    16. 内核级线程在一些关键点上优于用户级线程，但是内核级线程的速度慢。
    17. 调度程序激活机制
    18. 弹出式线程

3. 进程间通信：

    1. 竞争条件：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。
    2. 怎样避免竞争条件：互斥，以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。
    3. 临界区：我们把对共享内存进行访问的程序片段称作临界区。如果我们能够适当安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。
    4. 一个好的解决方案需要满足下面 4 个条件：
        1. 任何两个进程不能同时处于临界区
        2. 不应对 CPU 的速度和数量做任何假设
        3. 临界区对运行的进程不得阻塞其他进程
        4. 不得使进程无限期等待进入临界区
    5. 忙等待的互斥：
        1. 屏蔽中断：在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。CPU 只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断之后 CPU 将不会被切换到其他进程。一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不必担心其他进程介入。屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。
        2. 锁变量：设置一个共享变量，其初始值为 0.当这个进程想进入其临界区时，就先测试这把锁。如果该锁的值为 0，则该进程将其设为 1 并进入临界区。若这把锁的值已经是 1，则等待直到其变为 0。这种方案于假脱机目录存在一样的疏漏，还是会发生竞争条件。
        3. 严格轮换法：设置一个整型变量 turn，初始值为 0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程 0 检查 turn，发现其值为 0，于是进入临界区。进程 1 也发现其值为 0，所以在一个等待循环中不停地测试 turn，看其值何时变为 1.连续测试一变量直到某个值出现为止，称为**忙等待**。用于忙等待的锁，称为**自旋锁(spin lock)**。
            1. 由于这种方式浪费 CPU 时间，所以通常应该避免。
            2. 在一个进程比另一个进程慢了很多的情况下，轮流进入临界区并不是一个好办法。
            3. 这一方案虽然完全避免了所有的竞争条件，但是不满足条件 3`临界区对运行的进程不得阻塞其他进程`，因此也不是一个很好的方案。
        4. Peterson 解法：一种不需要严格轮换的软件互斥算法。
        5. TSL 指令
        6. XCHG 指令
        7. Peterson 解法和 TSL 指令或 XCHG 解法都是正确的，但它们都有忙等待的缺点。这些解法在本质上是这样的，当一个进程想进入临界区时，先检查是否允许进入。若不允许，则该进程将原地等待，直到允许为止。这种方法不仅浪费了 CPU 时间，而且还可能引起预想不到的结果。例如优先级反转问题
        8. 生产者-消费者问题，有界缓冲区问题。
        9. 信号量
            1. 一个信号量的取值可以为 0（表示没有保存下来的唤醒操作），或者为正值（表示有一个或多个唤醒操作）。
            2. 检查数值、修改变量值以及可能发生的睡眠操作均为一个点一的、不可分割的原子操作完成。保证一个信号量在完成或阻塞之前，其他进程均不允许访问该信号量。这种原子性对于解决同步问题和避免竞争条件是绝对必要的。
            3. 原子操作：所谓原子操作，是指一组相关联的操作要么都不间断的执行，要么都不执行。
            4. 信号量的另一种用途是用于实现同步。
        10. 互斥量
            1. 如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，成为互斥量。
            2. 互斥量仅仅适用于管理共享资源或一小段代码。
            3. 互斥量是一个可以处于两态之一的变量：解锁和加锁。
            4. 如果进程有不连续的空间地址，如何共享变量？
                1. 有些共享数据结构，例如信号量，可以放在内核中，并且只能通过系统调用来访问。
                2. 多数现代操作系统提供一种方法，让进程与其他进程共享其部分地址空间。这种方法中，缓冲区和其他数据结构可以共享。最坏的情况下，如果没有共享的途径，则可以共享文件。
            5. Pthread 中的互斥：Pthread 提供许多可以用来同步线程的函数。其基本机制是使用一个可以被锁定和解锁的互斥量来保护每个临界区。一个线程如果想要进入临界区，它首先尝试锁住相关互斥量。如果互斥量没有加锁，那么这个线程可以立即进入，并且该互斥量被自动锁定以防止其他线程进入。如果互斥量已被加锁，则调用线程被阻塞，直到该互斥量被解锁。如果多个线程在等待同一个互斥量，当它被解锁时，这些等待的线程中只有一个被允许并将互斥量重新锁定。这些互斥锁不是强制性的，而是由程序员来保证线程正确地使用它们。
            6. 除互斥量之外，pthread 提供了另一种同步机制：条件变量。互斥量在允许或阻塞对临界区的访问上是很有用的，条件变量则允许线程由于一些未达到的条件而阻塞。
            7. 条件变量不会存在内存中。如果将一个信号量传递给一个没有线程在等待的条件变量，那么这个信号就会丢失。
        11. 管程
            1. 死锁：两个进程都永久的阻塞下去，无法再进行有效的工作。
            2. 管程有一个很重要的特性，即任意时刻管程中只能有一个活跃进程，这一特性使管程能有效的完成互斥。
            3. 当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他活跃进程。如果有，调用进程将被挂起，直到另一个进程离开管程将其唤醒。如果没有活跃进程在使用管程，则该调用进程可以进入。
            4. 进入管程时的互斥由编译器负责，但通常的做法是用一个互斥量或二元信号量。因为是编译器而非程序员来安排互斥，所以出错的可能性要小的多。
            5. 通过临界区互斥的自动化，管程比信号量更容易保证并行编程的正确性。
        12. 消息传递
            1. 这种进程间通信的方法使用两条原语，send 和 receive，它们像信号量而不像管程，是系统调用而不是语言成分
            2. 消息传递系统的设计要点：
                1. 消息有可能被网络丢失。接收方在接收到消息的时候立刻回送一条确认消息。如果发送方在一段时间间隔没有收到消息，则重发消息。
                2. 消息有可能本身被正确接收，而返回给发送者的确认信息丢失，发送者将重发消息，这样接收者将接收到两次相同的消息。对于接收者来说，如何区分新的消息和重发的老消息非常重要。通常采用在每条原始消息中嵌入一个连续的序号来解决此类问题。如果接收者收到一条消息，它具有与前面某一条消息一样的序号，就知道这条消息是重复的，可以忽略。
                3. 消息系统还需要解决进程命名的问题，在 send 和 receive 调用中所指定的进程必须是没有二义性的。
                4. 消息系统的身份认证问题。客户机怎么直到它是与一个真正的文件服务器通信，而不是与一个冒充者通信。
            3. 用消息传递解决生产者-消费者问题
        13. 屏障：该同步机制是准备用于进程组而不是用于双进程的生产者-消费者类情形的。在有些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段。可以通过在每个阶段的结尾安置屏障来实现这种行为。当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。

4. 调度
    1. 调度程序：当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争 CPU。只要有两个或多个进程处于就绪状态，这种情形就会发生。如果只有一个 CPU 可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序。许多适用于进程调度的处理方法也同样适用于线程调度。
    2. 调度算法：调度程序使用的算法。
    3. 调度程序需要考虑 CPU 的利用率，因为进程切换的代价是比较高的：用户态必须切到内核态，然后要保存当前进程的状态，包括在进程表中存储寄存器以便以后重新装载。在许多系统中，内存映像也必须保存。然后通过调度算法选定一个新的进程，将该进程的内存映像重新装入 MMU，最后新进程开始运行。除此之外，进程切换还要使整个内存高速缓存失效，强迫缓存从内存中动态重新装入两次（进入内核一次，离开内核一次）。如果每秒钟切换进程的次数太多，会耗费大量 CPU 时间。
    4. 进程行为：几乎所有进程的 I/O 请求或计算都是交替突发的。CPU 不停顿地运行一段时间，然后发出一个系统调用以便读写文件。在完成系统调用之后，CPU 又开始计算，直到它需要读更多的数据或写更多的数据为止。
    5. 计算密集型：进程花费了绝大多数时间在计算上。
    6. I/O 密集型：进程在等待 I/O 上花费了绝大多数时间。
    7. 随着 CPU 变得越来越快，更多的进程倾向于 I/O 密集型。
    8. 何时进行调度决策：
        1. 在创建一个新进程之后，需要决定是运行父进程还是运行子进程。由于这两种进程都处于就绪状态，所以这是一种正常的调度决策，可以任意决定，也就是说，调度程序可以合法选择先运行父进程还是先运行子进程。
        2. 在一个进程退出时必须做出调度决策。如果没有就绪的进程，通常会运行一个系统提供的空闲进程。
        3. 当一个进程阻塞在 I/O 和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。
        4. 在一个 I/O 中断发生时，必须做出调度决策。
    9. 调度算法分类
