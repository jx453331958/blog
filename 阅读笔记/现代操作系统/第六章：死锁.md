# 现代操作系统

## 第 6 章 死锁

1. 在计算机系统中有很多独占性的资源，在任一时刻它们都只能被一个进程使用。例如打印机、磁带以及系统内部表中的表项。
2. 死锁：两个进程都被阻塞，并且一直处于这样的状态。
3. 资源：

    1. 大部分死锁都和资源相关。
    2. 需要排他性使用的对象称为资源。
    3. 资源可以是硬件设备或是一组信息
    4. 资源分为两类，可抢占资源和不可抢占资源
        1. 可抢占资源：可以从拥有它的进程中抢占而不会产生任何副作用
        2. 不可抢占资源：在不引起相关的计算失败的情况下，无法把资源从占有它的其他进程处抢占过来
    5. 使用一个资源所需要的事件顺序：
        1. 请求资源
        2. 使用资源
        3. 释放资源
    6. 若请求时资源不可用，则请求进程被迫等待。当一个进程请求资源失败时，它通常会处于循环状态：请求资源、休眠、再请求。

4. 死锁概述：

    1. 死锁的规范定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。
    2. 由于所有的进程都在等待，所以没有一个进程能引发可以唤醒该进程集合中的其他进程的事件，所有的进程都只好无限期地等待下去。
    3. 大多数情况下，每个进程所等待的事件是释放该进程集合中其他进程所占有的资源。
    4. 发生死锁的四个必要条件：
        1. 互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。
        2. 占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。
        3. 不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
        4. 环路等待条件。死锁发生时，系统中一定有两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。
    5. 死锁发生时，以上四个条件一定是同时满足的。如果其中任何一个条件不成立，死锁就不会发生。
    6. 处理死锁的四种策略：
        1. 忽略该问题。
        2. 检测死锁并恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动进行解决。
        3. 仔细对资源进行分配，动态地避免死锁。
        4. 通过破坏引起死锁的四个必要条件之一，防止死锁的产生。

5. 鸵鸟算法：假设问题没有发生。数学家认为无论代价有多大，都要彻底防止死锁的发生。工程师们则需要评估严重性，是否有必要彻底防止死锁。
6. 死锁检测和死锁恢复：使用这种技术时，系统并不试图阻止死锁的产生，而是允许死锁发生，当检测到死锁发生后，采取措施进行恢复。
    1. 死锁检测算法：
        1. 寻找一个没有标记的进程 Pi，对于它而言 R 矩阵的第 i 行向量小于或等于 A
        2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转到第一步
        3. 如果没有这样的进程，那么算法终止。算法结束时，所有没有标记过的进程都是死锁进程
    2. 从死锁中恢复
