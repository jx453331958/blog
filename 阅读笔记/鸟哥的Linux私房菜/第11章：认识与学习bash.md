# 鸟哥的Linux私房菜

## 第 11 章：认识与学习bash

1. 管理整个计算机硬件的其实是操作系统的内核，这个内核是需要被保护的，所以我们一般用户就只能通过shell来跟内核通信，以让内核达到我们想要达到的工作。
2. 变量内容可以用单引号或者双引号括起来，双引号内的特殊字符如$等，可以保有原本的特性，单引号内的特殊字符则为一般字符（纯文本）。
3. 在一串命令中，还需要通过其他的命令提供的信息，可以使用反引号`'命令'`或`$(命令)`
4. 取消变量的方法为使用`unset 变量名称`
5. 在变量的设置当中，单引号与双引号的用途有何不同？单引号与双引号的最大不同在于双引号仍然可以保有变量的内容，但单引号内仅能是一般字符，而不会有特殊符号。
6. 查看环境变量的命令：env或export
7. PATH: 执行文件查找的路径，目录与目录中间以冒号分隔
8. 用set命令查看所有变量，包括环境变量与自定义变量
9. $本身也是一个变量，这个代表的是目前这个shell的线程代号，即是所谓的PID(Process ID)
10. 环境变量与自定义变量的差异在于该变量是否会被子进程所继续引用。子进程会继承父进程的环境变量，子进程不会继承父进程的自定义变量。
11. 变量键盘读取命令：read
12. 声明变量类型：declare / typeset
13. 在默认情况下，bash对于变量有几个基本的定义：
    1. 变量类型默认为字符串，所以如果不指定变量类型，则1+2为一个字符串而不是计算式
    2. bash环境中的数值运算，默认最多仅能达到整数类型，所以1/3结果是0 
14. 数组的变量类型比较有趣的地方在于“读取”，一般来说，建议直接以${数组}的方式来读取，会比较正确无误
15. 与文件系统及程序的限制关系：ulimit

16. 变量内容的删除与替换：


| 变量设置方式                 | 说明                                                          |
| :--------------------------- | :------------------------------------------------------------ |
| `${变量#关键字}`             | 若变量内容从头开始的数据符合“关键字”，则将符合的最短数据删除  |
| `${变量##关键字}`            | 若变量内容从头开始的数据符合“关键字”，则将符合的最长数据删除  |
| `${变量%关键字}`             | 若变量内容从尾向前的数据符合“关键字”， 则将符合的最短数据删除 |
| `${变量%%关键字}`            | 若变量内容从尾向前的数据符合“关键字”， 则将符合的最长数据删除 |
| `${变量/旧字符串/新字符串}`  | 若变量内容符合“旧字符串”，则第一个旧字符串会被新字符串替换    |
| `${变量//旧字符串/新字符串}` | 若变量内容符合“旧字符串”，则全部旧字符串会被新字符串替换      |

17. 变量的测试与内容替换，减号“-”后面接的关键字可以给前面的变量赋默认值，即`new_var=${old_var-content}`，如果`old_var`没有值，则`content`被赋给`new_var`。

19. 变量设置方式：

|    变量设置方式    |     str没有设置     |    str为空字符串    | str已设置为非空字符串 |
| :----------------: | :-----------------: | :-----------------: | :-------------------: |
| `var=${str-expr}`  |     `var=expr`      |       `var=`        |      `var=$str`       |
| `var=${str:-expr}` |     `var=expr`      |     `var=expr`      |      `var=$str`       |
| `var=${str+expr}`  |       `var=`        |     `var=expr`      |      `var=expr`       |
| `var=${str:+expr}` |       `var=`        |       `var=`        |      `var=expr`       |
| `var=${str=expr}`  | `str=expr;var=expr` |   `str不变;var=`    |  `str不变;var=$str`   |
| `var=${str:=expr}` | `str=expr;var=expr` | `str=expr;var=expr` |  `str不变;var=$str`   |
| `var=${str?expr}`  | `expr输出至stderr`  |       `var=`        |       `var=str`       |
| `var=${str:?expr}` | `expr输出至stderr`  | `expr输出至stderr`  |       `var=str`       |

20. 命名别名与变量有什么不同？命名别名是新创一个新的命令，可以直接执行该命令的，至于变量则需要使用类似echo命令才能够调用变量的内容。
21. `!!`执行上一条命令，`!number`执行第number条命令，`!command`由最近的命令向前搜寻命令串开头为command的命令并执行。
22. 命令运行的顺序
    1. 以相对/绝对路径执行命令，例如"/bin/ls"或"./ls"；
    2. 由alias找到该命令来执行；
    3. 由bash内置的(builtin)命令来执行；
    4. 通过$PATH这个变量的顺序找到的第一个命令来执行；

23. login shell: 取得bash时需要完整的登录流程的，就称为login shell。
24. non-login shell: 取得bash接口的方法不需要重复登录的举动
25. 一般来说，login shell只会读取两个配置文件，/etc/profile和～/.bash_profile
26. /etc/profile: 这是系统整体的设置
27. ~/.bash_profile或~/.bash_login或~/.profile：属于用户个人配置
28. /etc/profile是每个用户登录取得bash时一定会读取的配置文件。这个文件设置的主要变量有：
    1. PATH: 会根据UID决定PATH变量要不要含有sbin的系统命令目录
    2. MAIL: 依据账号设置好用户的mailbox到/var/spool/mail/账号名
    3. USER: 根据用户的账号设置此变量的内容
    4. HOSTNAME: 根据主机的hostname命令决定此变量内容
    5. HISTSIZE: 历史命令记录条数

29. bash在读完了整体环境设置的/etc/profile并借此调用其他配置文件之后，接下来则是会读取用户的个人配置文件。在login shell的bash环境中，所读取的个人偏好文件主要有三个，~/.bash_profile、~/.bash_login、~/.profile。bash只会读取上面三个文件中的一个，而读取顺序则是按照上面的顺序。profile文件中会设置PATH这个变量。profile文件还会读取.bashrc文件的设置内容。bash配置文件的读入方式比较有趣，主要是通过一个命令"source"来读取的。login shell的读取流程，《鸟哥的linux私房菜》P323
30. source(读入环境配置文件的命令): 利用source或小数点(.)都可以将配置文件的内容读进目前的shell环境中。例如修改了.bashrc，那么不需要注销，立即执行 `source .bashrc`就可以将刚才新设置的内容读进目前的环境中。还有包括~/bash_profile以及/etc/profile的设置中，很多时候也都是利用到这个source(或小数点)的功能。
31. ~/.bash_logout：这个文件记录了当我注销bash后系统再帮我做完什么操作后才离开。
32. bash环境中的特殊符号：

|  符号   | 内容                                                  |
| :-----: | :---------------------------------------------------- |
|   `#`   | 注释符号                                              |
|   `\`   | 转义符号                                              |
|   `|`   | 管道                                                  |
|   `;`   | 连续命令执行分隔符，连续性命令的界定                  |
|   `~`   | 用户的主文件夹                                        |
|   `&`   | 使用变量前导符号                                      |
|   `!`   | 逻辑运算意义上的非                                    |
|   `/`   | 目录符号，路径分隔的符号                              |
| `>, >>` | 数据流重定向，输出导向，分别是“替换”与“累加”          |
| `<, <<` | 数据流重定向，输入导向                                |
|  `''`   | 单引号，不具有变量置换的功能                          |
|  `""`   | 双引号，具有变量置换的功能                            |
|   ``    | 反引号，两个反引号中间为可以先执行的命令，也可使用$() |
|  `()`   | 在中间为子shell的起始与结束                           |
|  `{}`   | 在中间为命令块的结合                                  |

33. standard output: 标准输出。指的是命令执行所回传的正确的信息。
34. standard error output: 标准错误输出。指的是命令执行失败后，回传的错误信息。
35. 数据流重定向可以将standard output(简称stdout)与standard error output(简称stderr)分别传送到其他的文件或设备去，分别传送所用的特殊字符如下所示：
    1. 标准输入(stdin): 代码为0，使用`<`或`<<`
    2. 标准输出(stdout): 代码为1，使用`>`或`>>`
    3. 标准错误输出(stderr): 代码为2，使用`2>`或`2>>`

36. /dev/null垃圾桶黑洞设备：如果想让信息忽略掉不显示或存储，就将数据流重定向到黑洞设备/dev/null
37. 将正确数据与错误数据同时写入同一个文件：

```shell
// 错误做法，由于两条数据同时写入一个文件，又没有使用特殊的语法，此时两条数据可能会交叉写入该文件内，造成次序的混乱。
find /home -name .bashrc > list 2> list

// 正确做法
find /home -name .bashrc > list 2>&1

// 正确做法
find /home -name .bashrc &> list
```

38. 标准输入：用某个文件的内容来代替键盘的敲击， `<`表示将原本需要由键盘输入的数据改为由文件内容来替代。`<<`代表的时结束输入的意思。利用`<<`右侧的控制字符，我们可以终止一次输入，而不必输入[ctrl]+d来结束。

```shell
cat > catfile < ~/.bashrc

// 用cat直接将输入信息输出到catfile中，且当由键盘输入eof时，该输入就结束
cat > catfile << "eof"
```

39. `cmd;cmd`(不考虑命令相关性的连续命令执行): 在某些时候，我们希望可以一次执行多个命令，在命令与命令中间利用分号隔开，分号前的命令执行完后就会立刻接着执行分号后面的命令。适用于两个命令之间没有相关性的情况。如果前一个命令是否成功的执行与后一个命令是否要执行相关，那就得用`&&`或`||`。
40. `$?`(命令回传码)与`&&`或`||`： 若前一个命令执行的结果为正确，在Linux下面会回传一个`&?=0`的值。通过这个回传码来判断后续的命令是否要执行，就得用`&&`及`||`。

|命令执行情况|说明|
|:-|:-|
|`cmd1 && cmd2`|若cmd1执行完毕且正确执行($?=0), 则开始执行cmd2；若cmd1执行完毕且为错误($?≠0), 则cmd2不执行|
|`cmd1 || cmd2`|若cmd1执行完毕且正确执行($?=0), 则cmd2不执行；若cmd1执行完毕且为错误($?≠0), 则开始执行cmd2|

```shell
// 使用ls查阅目录/tmp/abc是否存在，若存在则用touch创建/tmp/abc/hehe
ls /tmp/abc && touch /tmp/abc/hehe
```

41. 管道命令：管道命令仅能处理经由前面一个命令传来的正确信息，也就是standard output信息，对于standard error并没有直接处理的能力。管道命令对于standard error output会予以忽略。管道命令必须要能够接收来自前一个命令的数据成为standard input继续处理才行。

42. 选取命令：cut, grep。一般来说，选取信息通常是针对“行”来分析的，并不是整篇信息分析的。

43. cut: 主要的用途在于将同一行里面的数据进行分解，最常使用在分析一些数据或文字数据的时候。
```shell
cut -d'分隔字符' -f fields <==用于分隔字符
cut -c'字符范围'

参数：
-d: 后面接分隔字符，与-f一起使用；
-f: 依据-d的分隔字符将一段信息切割成数段，用-f取出第几段的意思；
-c: 以字符的单位取出固定字符区间
```

44. grep: cut是在一行信息当中取出某部分我们想要的，而grep则是分析一行信息，若当中有我们需要的信息，就把该行拿出来。

```shell
grep [-acinv] [--color=auto] '查找字符串' filename

参数：
-a: 将binary文件以text文件的方式查找数据；
-c: 计算找到'查找字符串'的次数；
-i: 忽略大小写的不同，所以大小写视为相同；
-n: 顺便输出行号；
-v: 反向选择，即显示出没有'查找关键字'内容的那一行；
--color=auto: 可以将找到的关键字部分加上颜色显示；
```

45. sort: 排序命令，可以依据不同的数据类型来排序。
46. uniq: 去重命令，将重复的行删除掉只显示一个。
47. wc: 计算输出信息的整体数据。
48. tee: 双向重定向命令。tee会同时将数据流送与文件与屏幕，而输出到屏幕的，其实就是stdout，可以让下个命令继续处理。
49. tr: 可以用来删除一段信息当中的文字，或者是进行文字信息的替换。
50. col: 将tab替换成空格，将man page转存为纯文本文件以方便查阅。
51. join: 文件之间数据拼接。在使用join之前，所需要处理的文件应该要事先经过排序处理。
52. paste: 将两行贴在一起，中间以tab键隔开。
